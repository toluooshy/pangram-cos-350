{"ast":null,"code":"/*! @azure/msal-common v15.13.2 2025-11-19 */\n'use strict';\n\nimport { CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from './entities/AccountEntity.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { updateAccountTenantProfileData } from '../account/AccountInfo.mjs';\nimport { extractTokenClaims } from '../account/AuthToken.mjs';\nimport { name, version } from '../packageMetadata.mjs';\nimport { getAliasesFromStaticSources } from '../authority/AuthorityMetadata.mjs';\nimport { createCacheError } from '../error/CacheError.mjs';\nimport { AuthError } from '../error/AuthError.mjs';\nimport { invalidCacheRecord, multipleMatchingAppMetadata, methodNotImplemented } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n * @internal\r\n */\nclass CacheManager {\n  constructor(clientId, cryptoImpl, logger, performanceClient, staticAuthorityOptions) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n    this.staticAuthorityOptions = staticAuthorityOptions;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\r\n   * @param accountFilter - (Optional) filter to narrow down the accounts returned\r\n   * @returns Array of AccountInfo objects in cache\r\n   */\n  getAllAccounts(accountFilter, correlationId) {\n    return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter, correlationId), correlationId, accountFilter);\n  }\n  /**\r\n   * Gets first tenanted AccountInfo object found based on provided filters\r\n   */\n  getAccountInfoFilteredBy(accountFilter, correlationId) {\n    if (Object.keys(accountFilter).length === 0 || Object.values(accountFilter).every(value => !value)) {\n      this.commonLogger.warning(\"getAccountInfoFilteredBy: Account filter is empty or invalid, returning null\");\n      return null;\n    }\n    const allAccounts = this.getAllAccounts(accountFilter, correlationId);\n    if (allAccounts.length > 1) {\n      // If one or more accounts are found, prioritize accounts that have an ID token\n      const sortedAccounts = allAccounts.sort(account => {\n        return account.idTokenClaims ? -1 : 1;\n      });\n      return sortedAccounts[0];\n    } else if (allAccounts.length === 1) {\n      // If only one account is found, return it regardless of whether a matching ID token was found\n      return allAccounts[0];\n    } else {\n      return null;\n    }\n  }\n  /**\r\n   * Returns a single matching\r\n   * @param accountFilter\r\n   * @returns\r\n   */\n  getBaseAccountInfo(accountFilter, correlationId) {\n    const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);\n    if (accountEntities.length > 0) {\n      return AccountEntity.getAccountInfo(accountEntities[0]);\n    } else {\n      return null;\n    }\n  }\n  /**\r\n   * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters\r\n   * and builds the account info objects from the matching ID token's claims\r\n   * @param cachedAccounts\r\n   * @param accountFilter\r\n   * @returns Array of AccountInfo objects that match account and tenant profile filters\r\n   */\n  buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {\n    return cachedAccounts.flatMap(accountEntity => {\n      return this.getTenantProfilesFromAccountEntity(accountEntity, correlationId, accountFilter?.tenantId, accountFilter);\n    });\n  }\n  getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter) {\n    let tenantedAccountInfo = null;\n    let idTokenClaims;\n    if (tenantProfileFilter) {\n      if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {\n        return null;\n      }\n    }\n    const idToken = this.getIdToken(accountInfo, correlationId, tokenKeys, tenantProfile.tenantId);\n    if (idToken) {\n      idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);\n      if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {\n        // ID token sourced claims don't match so this tenant profile is not a match\n        return null;\n      }\n    }\n    // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims\n    tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);\n    return tenantedAccountInfo;\n  }\n  getTenantProfilesFromAccountEntity(accountEntity, correlationId, targetTenantId, tenantProfileFilter) {\n    const accountInfo = AccountEntity.getAccountInfo(accountEntity);\n    let searchTenantProfiles = accountInfo.tenantProfiles || new Map();\n    const tokenKeys = this.getTokenKeys();\n    // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists\n    if (targetTenantId) {\n      const tenantProfile = searchTenantProfiles.get(targetTenantId);\n      if (tenantProfile) {\n        // Reduce search field to just this tenant profile\n        searchTenantProfiles = new Map([[targetTenantId, tenantProfile]]);\n      } else {\n        // No tenant profile for search tenant ID, return empty array\n        return [];\n      }\n    }\n    const matchingTenantProfiles = [];\n    searchTenantProfiles.forEach(tenantProfile => {\n      const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter);\n      if (tenantedAccountInfo) {\n        matchingTenantProfiles.push(tenantedAccountInfo);\n      }\n    });\n    return matchingTenantProfiles;\n  }\n  tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {\n    if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {\n      return false;\n    }\n    if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {\n      return false;\n    }\n    if (tenantProfileFilter.isHomeTenant !== undefined && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {\n      return false;\n    }\n    return true;\n  }\n  idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {\n    // Tenant Profile filtering\n    if (tenantProfileFilter) {\n      if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord {CacheRecord}\r\n   * @param correlationId {?string} correlation id\r\n   * @param kmsi - Keep Me Signed In\r\n   * @param storeInCache {?StoreInCache}\r\n   */\n  async saveCacheRecord(cacheRecord, correlationId, kmsi, storeInCache) {\n    if (!cacheRecord) {\n      throw createClientAuthError(invalidCacheRecord);\n    }\n    try {\n      if (!!cacheRecord.account) {\n        await this.setAccount(cacheRecord.account, correlationId, kmsi);\n      }\n      if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n        await this.setIdTokenCredential(cacheRecord.idToken, correlationId, kmsi);\n      }\n      if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\n        await this.saveAccessToken(cacheRecord.accessToken, correlationId, kmsi);\n      }\n      if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {\n        await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId, kmsi);\n      }\n      if (!!cacheRecord.appMetadata) {\n        this.setAppMetadata(cacheRecord.appMetadata, correlationId);\n      }\n    } catch (e) {\n      this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);\n      if (e instanceof AuthError) {\n        throw e;\n      } else {\n        throw createCacheError(e);\n      }\n    }\n  }\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n  async saveAccessToken(credential, correlationId, kmsi) {\n    const accessTokenFilter = {\n      clientId: credential.clientId,\n      credentialType: credential.credentialType,\n      environment: credential.environment,\n      homeAccountId: credential.homeAccountId,\n      realm: credential.realm,\n      tokenType: credential.tokenType,\n      requestedClaimsHash: credential.requestedClaimsHash\n    };\n    const tokenKeys = this.getTokenKeys();\n    const currentScopes = ScopeSet.fromString(credential.target);\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n        return;\n      }\n      const tokenEntity = this.getAccessTokenCredential(key, correlationId);\n      if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n        const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n        if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n          this.removeAccessToken(key, correlationId);\n        }\n      }\n    });\n    await this.setAccessTokenCredential(credential, correlationId, kmsi);\n  }\n  /**\r\n   * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache\r\n   * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param accountFilter - An object containing Account properties to filter by\r\n   */\n  getAccountsFilteredBy(accountFilter, correlationId) {\n    const allAccountKeys = this.getAccountKeys();\n    const matchingAccounts = [];\n    allAccountKeys.forEach(cacheKey => {\n      const entity = this.getAccount(cacheKey, correlationId);\n      // Match base account fields\n      if (!entity) {\n        return;\n      }\n      if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {\n        return;\n      }\n      if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n      if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n      if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {\n        return;\n      }\n      // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts\n      const tenantProfileFilter = {\n        localAccountId: accountFilter?.localAccountId,\n        name: accountFilter?.name\n      };\n      const matchingTenantProfiles = entity.tenantProfiles?.filter(tenantProfile => {\n        return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);\n      });\n      if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {\n        // No tenant profile for this account matches filter, don't add to list of matching accounts\n        return;\n      }\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  }\n  /**\r\n   * Returns whether or not the given credential entity matches the filter\r\n   * @param entity\r\n   * @param filter\r\n   * @returns\r\n   */\n  credentialMatchesFilter(entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\r\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n     */\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\r\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n     */\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    }\n    // If request OR cached entity has requested Claims Hash, check if they match\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    }\n    // Access Token with Auth Scheme specific matching\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      }\n      // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n  getAppMetadataFilteredBy(filter) {\n    const allCacheKeys = this.getKeys();\n    const matchingAppMetadata = {};\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-appMetadata type cache entities\n      if (!this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n        return;\n      }\n      if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  }\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n  getAuthorityMetadataByAlias(host) {\n    const allCacheKeys = this.getAuthorityMetadataKeys();\n    let matchedEntity = null;\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  }\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n  removeAllAccounts(correlationId) {\n    const accounts = this.getAllAccounts({}, correlationId);\n    accounts.forEach(account => {\n      this.removeAccount(account, correlationId);\n    });\n  }\n  /**\r\n   * Removes the account and related tokens for a given account key\r\n   * @param account\r\n   */\n  removeAccount(account, correlationId) {\n    this.removeAccountContext(account, correlationId);\n    const accountKeys = this.getAccountKeys();\n    const keyFilter = key => {\n      return key.includes(account.homeAccountId) && key.includes(account.environment);\n    };\n    accountKeys.filter(keyFilter).forEach(key => {\n      this.removeItem(key, correlationId);\n      this.performanceClient.incrementFields({\n        accountsRemoved: 1\n      }, correlationId);\n    });\n  }\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  removeAccountContext(account, correlationId) {\n    const allTokenKeys = this.getTokenKeys();\n    const keyFilter = key => {\n      return key.includes(account.homeAccountId) && key.includes(account.environment);\n    };\n    allTokenKeys.idToken.filter(keyFilter).forEach(key => {\n      this.removeIdToken(key, correlationId);\n    });\n    allTokenKeys.accessToken.filter(keyFilter).forEach(key => {\n      this.removeAccessToken(key, correlationId);\n    });\n    allTokenKeys.refreshToken.filter(keyFilter).forEach(key => {\n      this.removeRefreshToken(key, correlationId);\n    });\n  }\n  /**\r\n   * Removes accessToken from the cache\r\n   * @param key\r\n   * @param correlationId\r\n   */\n  removeAccessToken(key, correlationId) {\n    const credential = this.getAccessTokenCredential(key, correlationId);\n    this.removeItem(key, correlationId);\n    this.performanceClient.incrementFields({\n      accessTokensRemoved: 1\n    }, correlationId);\n    if (!credential || credential.credentialType.toLowerCase() !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() || credential.tokenType !== AuthenticationScheme.POP) {\n      // If the credential is not a PoP token, we can return\n      return;\n    }\n    // Remove Token Binding Key from key store for PoP Tokens Credentials\n    const kid = credential.keyId;\n    if (kid) {\n      void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {\n        this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);\n        this.performanceClient?.incrementFields({\n          removeTokenBindingKeyFailure: 1\n        }, correlationId);\n      });\n    }\n  }\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n  removeAppMetadata(correlationId) {\n    const allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(cacheKey => {\n      if (this.isAppMetadata(cacheKey)) {\n        this.removeItem(cacheKey, correlationId);\n      }\n    });\n    return true;\n  }\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param account {AccountInfo}\r\n   * @param tokenKeys {?TokenKeys}\r\n   * @param targetRealm {?string}\r\n   * @param performanceClient {?IPerformanceClient}\r\n   * @param correlationId {?string}\r\n   */\n  getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    const idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: targetRealm\n    };\n    const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);\n    const numIdTokens = idTokenMap.size;\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      let tokensToBeRemoved = idTokenMap;\n      // Multiple tenant profiles and no tenant specified, pick home account\n      if (!targetRealm) {\n        const homeIdTokenMap = new Map();\n        idTokenMap.forEach((idToken, key) => {\n          if (idToken.realm === account.tenantId) {\n            homeIdTokenMap.set(key, idToken);\n          }\n        });\n        const numHomeIdTokens = homeIdTokenMap.size;\n        if (numHomeIdTokens < 1) {\n          this.commonLogger.info(\"CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result\");\n          return idTokenMap.values().next().value;\n        } else if (numHomeIdTokens === 1) {\n          this.commonLogger.info(\"CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile\");\n          return homeIdTokenMap.values().next().value;\n        } else {\n          // Multiple ID tokens for home tenant profile, remove all and return null\n          tokensToBeRemoved = homeIdTokenMap;\n        }\n      }\n      // Multiple tokens for a single tenant profile, remove all and return null\n      this.commonLogger.info(\"CacheManager:getIdToken - Multiple matching ID tokens found, clearing them\");\n      tokensToBeRemoved.forEach((idToken, key) => {\n        this.removeIdToken(key, correlationId);\n      });\n      if (performanceClient && correlationId) {\n        performanceClient.addFields({\n          multiMatchedID: idTokenMap.size\n        }, correlationId);\n      }\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning ID token\");\n    return idTokenMap.values().next().value;\n  }\n  /**\r\n   * Gets all idTokens matching the given filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  getIdTokensByFilter(filter, correlationId, tokenKeys) {\n    const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    const idTokens = new Map();\n    idTokenKeys.forEach(key => {\n      if (!this.idTokenKeyMatchesFilter(key, {\n        clientId: this.clientId,\n        ...filter\n      })) {\n        return;\n      }\n      const idToken = this.getIdTokenCredential(key, correlationId);\n      if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.set(key, idToken);\n      }\n    });\n    return idTokens;\n  }\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @returns\r\n   */\n  idTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Removes idToken from the cache\r\n   * @param key\r\n   */\n  removeIdToken(key, correlationId) {\n    this.removeItem(key, correlationId);\n  }\n  /**\r\n   * Removes refresh token from the cache\r\n   * @param key\r\n   */\n  removeRefreshToken(key, correlationId) {\n    this.removeItem(key, correlationId);\n  }\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param account {AccountInfo}\r\n   * @param request {BaseAuthRequest}\r\n   * @param correlationId {?string}\r\n   * @param tokenKeys {?TokenKeys}\r\n   * @param performanceClient {?IPerformanceClient}\r\n   */\n  getAccessToken(account, request, tokenKeys, targetRealm) {\n    const correlationId = request.correlationId;\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\", correlationId);\n    const scopes = ScopeSet.createSearchScopes(request.scopes);\n    const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    const accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: targetRealm || account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    const accessTokens = [];\n    accessTokenKeys.forEach(key => {\n      // Validate key\n      if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        const accessToken = this.getAccessTokenCredential(key, correlationId);\n        // Validate value\n        if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    const numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\", correlationId);\n      return null;\n    } else if (numAccessTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\", correlationId);\n      accessTokens.forEach(accessToken => {\n        this.removeAccessToken(this.generateCredentialKey(accessToken), correlationId);\n      });\n      this.performanceClient.addFields({\n        multiMatchedAT: accessTokens.length\n      }, correlationId);\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\", correlationId);\n    return accessTokens[0];\n  }\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @param keyMustContainAllScopes\r\n   * @returns\r\n   */\n  accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.target) {\n      const scopes = filter.target.asArray();\n      for (let i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n    return true;\n  }\n  /**\r\n   * Gets all access tokens matching the filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  getAccessTokensByFilter(filter, correlationId) {\n    const tokenKeys = this.getTokenKeys();\n    const accessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n      const accessToken = this.getAccessTokenCredential(key, correlationId);\n      if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  }\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param account {AccountInfo}\r\n   * @param familyRT {boolean}\r\n   * @param correlationId {?string}\r\n   * @param tokenKeys {?TokenKeys}\r\n   * @param performanceClient {?IPerformanceClient}\r\n   */\n  getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    const id = familyRT ? THE_FAMILY_ID : undefined;\n    const refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    const refreshTokens = [];\n    refreshTokenKeys.forEach(key => {\n      // Validate key\n      if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        const refreshToken = this.getRefreshTokenCredential(key, correlationId);\n        // Validate value\n        if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    const numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    if (numRefreshTokens > 1 && performanceClient && correlationId) {\n      performanceClient.addFields({\n        multiMatchedRT: numRefreshTokens\n      }, correlationId);\n    }\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  }\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   */\n  refreshTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    }\n    // If familyId is used, clientId is not in the key\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n  readAppMetadataFromCache(environment) {\n    const appMetadataFilter = {\n      environment,\n      clientId: this.clientId\n    };\n    const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    const appMetadataEntries = Object.keys(appMetadata).map(key => appMetadata[key]);\n    const numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw createClientAuthError(multipleMatchingAppMetadata);\n    }\n    return appMetadataEntries[0];\n  }\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  isAppMetadataFOCI(environment) {\n    const appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  }\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n  matchHomeAccountId(entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  }\n  /**\r\n   * helper to match account ids\r\n   * @param entity\r\n   * @param localAccountId\r\n   * @returns\r\n   */\n  matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {\n    const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;\n    return localAccountId === idTokenLocalAccountId;\n  }\n  matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {\n    return tenantProfile.localAccountId === localAccountId;\n  }\n  /**\r\n   * helper to match names\r\n   * @param entity\r\n   * @param name\r\n   * @returns true if the downcased name properties are present and match in the filter and the entity\r\n   */\n  matchName(claims, name) {\n    return !!(name.toLowerCase() === claims.name?.toLowerCase());\n  }\n  /**\r\n   * helper to match usernames\r\n   * @param entity\r\n   * @param username\r\n   * @returns\r\n   */\n  matchUsername(cachedUsername, filterUsername) {\n    return !!(cachedUsername && typeof cachedUsername === \"string\" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());\n  }\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n  matchUserAssertionHash(entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  }\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n  matchEnvironment(entity, environment) {\n    // Check static authority options first for cases where authority metadata has not been resolved and cached yet\n    if (this.staticAuthorityOptions) {\n      const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);\n      if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {\n        return true;\n      }\n    }\n    // Query metadata cache if no static authority configuration has aliases that match enviroment\n    const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n  matchCredentialType(entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  }\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n  matchClientId(entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  }\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n  matchFamilyId(entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  }\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n  matchRealm(entity, realm) {\n    return !!(entity.realm?.toLowerCase() === realm.toLowerCase());\n  }\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n  matchNativeAccountId(entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  }\n  /**\r\n   * helper to match loginHint which can be either:\r\n   * 1. login_hint ID token claim\r\n   * 2. username in cached account object\r\n   * 3. upn in ID token claims\r\n   * @param entity\r\n   * @param loginHint\r\n   * @returns\r\n   */\n  matchLoginHintFromTokenClaims(tokenClaims, loginHint) {\n    if (tokenClaims.login_hint === loginHint) {\n      return true;\n    }\n    if (tokenClaims.preferred_username === loginHint) {\n      return true;\n    }\n    if (tokenClaims.upn === loginHint) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Helper to match sid\r\n   * @param entity\r\n   * @param sid\r\n   * @returns true if the sid claim is present and matches the filter\r\n   */\n  matchSid(idTokenClaims, sid) {\n    return idTokenClaims.sid === sid;\n  }\n  matchAuthorityType(entity, authorityType) {\n    return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());\n  }\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n  matchTarget(entity, target) {\n    const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    const entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  }\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  matchTokenType(entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  }\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param keyId\r\n   */\n  matchKeyId(entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  }\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n  isAppMetadata(key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  }\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n  isAuthorityMetadata(key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  }\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n  generateAuthorityMetadataCacheKey(authority) {\n    return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n  }\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n  static toObject(obj, json) {\n    for (const propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  }\n}\n/** @internal */\nclass DefaultStorageClass extends CacheManager {\n  async setAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  async setIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  async setAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  async setRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadataKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  removeItem() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccountKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getTokenKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  generateCredentialKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  generateAccountKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n}\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"names":["CacheManager","constructor","clientId","cryptoImpl","logger","performanceClient","staticAuthorityOptions","commonLogger","clone","name","version","getAllAccounts","accountFilter","correlationId","buildTenantProfiles","getAccountsFilteredBy","getAccountInfoFilteredBy","Object","keys","length","values","every","value","warning","allAccounts","sortedAccounts","sort","account","idTokenClaims","getBaseAccountInfo","accountEntities","AccountEntity","getAccountInfo","cachedAccounts","flatMap","accountEntity","getTenantProfilesFromAccountEntity","tenantId","getTenantedAccountInfoByFilter","accountInfo","tokenKeys","tenantProfile","tenantProfileFilter","tenantedAccountInfo","tenantProfileMatchesFilter","idToken","getIdToken","extractTokenClaims","secret","base64Decode","idTokenClaimsMatchTenantProfileFilter","updateAccountTenantProfileData","targetTenantId","searchTenantProfiles","tenantProfiles","Map","getTokenKeys","get","matchingTenantProfiles","forEach","push","localAccountId","matchLocalAccountIdFromTenantProfile","isHomeTenant","undefined","matchLocalAccountIdFromTokenClaims","loginHint","matchLoginHintFromTokenClaims","username","matchUsername","preferred_username","matchName","sid","matchSid","saveCacheRecord","cacheRecord","kmsi","storeInCache","createClientAuthError","invalidCacheRecord","setAccount","setIdTokenCredential","accessToken","saveAccessToken","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","e","error","AuthError","createCacheError","credential","accessTokenFilter","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","currentScopes","ScopeSet","fromString","target","key","accessTokenKeyMatchesFilter","tokenEntity","getAccessTokenCredential","credentialMatchesFilter","tokenScopeSet","intersectingScopeSets","removeAccessToken","setAccessTokenCredential","allAccountKeys","getAccountKeys","matchingAccounts","cacheKey","entity","getAccount","matchHomeAccountId","matchEnvironment","matchRealm","nativeAccountId","matchNativeAccountId","authorityType","matchAuthorityType","filter","matchClientId","userAssertionHash","matchUserAssertionHash","matchCredentialType","familyId","matchFamilyId","matchTarget","CredentialType","ACCESS_TOKEN_WITH_AUTH_SCHEME","matchTokenType","AuthenticationScheme","SSH","keyId","matchKeyId","getAppMetadataFilteredBy","allCacheKeys","getKeys","matchingAppMetadata","isAppMetadata","getAppMetadata","getAuthorityMetadataByAlias","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","indexOf","getAuthorityMetadata","aliases","removeAllAccounts","accounts","removeAccount","removeAccountContext","accountKeys","keyFilter","includes","removeItem","incrementFields","accountsRemoved","allTokenKeys","removeIdToken","removeRefreshToken","accessTokensRemoved","toLowerCase","POP","kid","removeTokenBindingKey","catch","removeTokenBindingKeyFailure","removeAppMetadata","targetRealm","trace","idTokenFilter","ID_TOKEN","idTokenMap","getIdTokensByFilter","numIdTokens","size","info","tokensToBeRemoved","homeIdTokenMap","set","numHomeIdTokens","next","addFields","multiMatchedID","idTokenKeys","idTokens","idTokenKeyMatchesFilter","getIdTokenCredential","inputKey","getAccessToken","request","scopes","createSearchScopes","authScheme","authenticationScheme","BEARER","ACCESS_TOKEN","sshKid","accessTokenKeys","accessTokens","numAccessTokens","generateCredentialKey","multiMatchedAT","keyMustContainAllScopes","asArray","i","getAccessTokensByFilter","getRefreshToken","familyRT","id","THE_FAMILY_ID","refreshTokenFilter","REFRESH_TOKEN","refreshTokenKeys","refreshTokens","refreshTokenKeyMatchesFilter","getRefreshTokenCredential","numRefreshTokens","multiMatchedRT","readAppMetadataFromCache","appMetadataFilter","appMetadataEntries","map","numAppMetadata","multipleMatchingAppMetadata","isAppMetadataFOCI","tokenClaims","idTokenLocalAccountId","oid","sub","claims","cachedUsername","filterUsername","staticAliases","getAliasesFromStaticSources","cloudMetadata","login_hint","upn","isNotAccessTokenCredential","entityScopeSet","containsScopeSet","APP_METADATA","AUTHORITY_METADATA_CONSTANTS","CACHE_KEY","generateAuthorityMetadataCacheKey","authority","toObject","obj","json","propertyName","DefaultStorageClass","methodNotImplemented","setServerTelemetry","getServerTelemetry","setAuthorityMetadata","setThrottlingCache","getThrottlingCache","generateAccountKey"],"sources":["/Users/tolu/pangram-cos-350/frontend/node_modules/@azure/msal-common/src/cache/CacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountFilter,\n    CredentialFilter,\n    ValidCredentialType,\n    AppMetadataFilter,\n    AppMetadataCache,\n    TokenKeys,\n    TenantProfileFilter,\n} from \"./utils/CacheTypes.js\";\nimport { CacheRecord } from \"./entities/CacheRecord.js\";\nimport {\n    CredentialType,\n    APP_METADATA,\n    THE_FAMILY_ID,\n    AUTHORITY_METADATA_CONSTANTS,\n    AuthenticationScheme,\n} from \"../utils/Constants.js\";\nimport { CredentialEntity } from \"./entities/CredentialEntity.js\";\nimport { ScopeSet } from \"../request/ScopeSet.js\";\nimport { AccountEntity } from \"./entities/AccountEntity.js\";\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity.js\";\nimport { IdTokenEntity } from \"./entities/IdTokenEntity.js\";\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity.js\";\nimport { ICacheManager } from \"./interface/ICacheManager.js\";\nimport {\n    createClientAuthError,\n    ClientAuthErrorCodes,\n} from \"../error/ClientAuthError.js\";\nimport {\n    AccountInfo,\n    TenantProfile,\n    updateAccountTenantProfileData,\n} from \"../account/AccountInfo.js\";\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity.js\";\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity.js\";\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity.js\";\nimport { extractTokenClaims } from \"../account/AuthToken.js\";\nimport { ICrypto } from \"../crypto/ICrypto.js\";\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity.js\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest.js\";\nimport { Logger } from \"../logger/Logger.js\";\nimport { name, version } from \"../packageMetadata.js\";\nimport { StoreInCache } from \"../request/StoreInCache.js\";\nimport { getAliasesFromStaticSources } from \"../authority/AuthorityMetadata.js\";\nimport { StaticAuthorityOptions } from \"../authority/AuthorityOptions.js\";\nimport { TokenClaims } from \"../account/TokenClaims.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { createCacheError } from \"../error/CacheError.js\";\nimport { AuthError } from \"../error/AuthError.js\";\n\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n * @internal\n */\nexport abstract class CacheManager implements ICacheManager {\n    protected clientId: string;\n    protected cryptoImpl: ICrypto;\n    // Instance of logger for functions defined in the msal-common layer\n    private commonLogger: Logger;\n    private staticAuthorityOptions?: StaticAuthorityOptions;\n    protected performanceClient: IPerformanceClient;\n\n    constructor(\n        clientId: string,\n        cryptoImpl: ICrypto,\n        logger: Logger,\n        performanceClient: IPerformanceClient,\n        staticAuthorityOptions?: StaticAuthorityOptions\n    ) {\n        this.clientId = clientId;\n        this.cryptoImpl = cryptoImpl;\n        this.commonLogger = logger.clone(name, version);\n        this.staticAuthorityOptions = staticAuthorityOptions;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     *  @param accountKey\n     */\n    abstract getAccount(\n        accountKey: string,\n        correlationId: string\n    ): AccountEntity | null;\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     * @param correlationId\n     */\n    abstract setAccount(\n        account: AccountEntity,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<void>;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param idTokenKey\n     */\n    abstract getIdTokenCredential(\n        idTokenKey: string,\n        correlationId: string\n    ): IdTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param idToken\n     * @param correlationId\n     */\n    abstract setIdTokenCredential(\n        idToken: IdTokenEntity,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<void>;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param accessTokenKey\n     */\n    abstract getAccessTokenCredential(\n        accessTokenKey: string,\n        correlationId: string\n    ): AccessTokenEntity | null;\n\n    /**\n     * set accessToken entity to the platform cache\n     * @param accessToken\n     * @param correlationId\n     */\n    abstract setAccessTokenCredential(\n        accessToken: AccessTokenEntity,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<void>;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param refreshTokenKey\n     */\n    abstract getRefreshTokenCredential(\n        refreshTokenKey: string,\n        correlationId: string\n    ): RefreshTokenEntity | null;\n\n    /**\n     * set refreshToken entity to the platform cache\n     * @param refreshToken\n     * @param correlationId\n     */\n    abstract setRefreshTokenCredential(\n        refreshToken: RefreshTokenEntity,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<void>;\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    abstract setAppMetadata(\n        appMetadata: AppMetadataEntity,\n        correlationId: string\n    ): void;\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    abstract getServerTelemetry(\n        serverTelemetryKey: string\n    ): ServerTelemetryEntity | null;\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    abstract setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity,\n        correlationId: string\n    ): void;\n\n    /**\n     * fetch cloud discovery metadata entity from the platform cache\n     * @param key\n     */\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\n\n    /**\n     *\n     */\n    abstract getAuthorityMetadataKeys(): Array<string>;\n\n    /**\n     * set cloud discovery metadata entity to the platform cache\n     * @param key\n     * @param value\n     */\n    abstract setAuthorityMetadata(\n        key: string,\n        value: AuthorityMetadataEntity\n    ): void;\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    abstract getThrottlingCache(\n        throttlingCacheKey: string\n    ): ThrottlingEntity | null;\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    abstract setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity,\n        correlationId: string\n    ): void;\n\n    /**\n     * Function to remove an item from cache given its key.\n     * @param key\n     */\n    abstract removeItem(key: string, correlationId: string): void;\n\n    /**\n     * Function which retrieves all current keys from the cache.\n     */\n    abstract getKeys(): string[];\n\n    /**\n     * Function which retrieves all account keys from the cache\n     */\n    abstract getAccountKeys(): string[];\n\n    /**\n     * Function which retrieves all token keys from the cache\n     */\n    abstract getTokenKeys(): TokenKeys;\n\n    /**\n     * Returns credential cache key from the entity\n     * @param credential\n     */\n    abstract generateCredentialKey(credential: CredentialEntity): string;\n\n    /**\n     * Returns the account cache key from the account info\n     * @param account\n     */\n    abstract generateAccountKey(account: AccountInfo): string;\n\n    /**\n     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\n     * @param accountFilter - (Optional) filter to narrow down the accounts returned\n     * @returns Array of AccountInfo objects in cache\n     */\n    getAllAccounts(\n        accountFilter: AccountFilter,\n        correlationId: string\n    ): AccountInfo[] {\n        return this.buildTenantProfiles(\n            this.getAccountsFilteredBy(accountFilter, correlationId),\n            correlationId,\n            accountFilter\n        );\n    }\n\n    /**\n     * Gets first tenanted AccountInfo object found based on provided filters\n     */\n    getAccountInfoFilteredBy(\n        accountFilter: AccountFilter,\n        correlationId: string\n    ): AccountInfo | null {\n        if (\n            Object.keys(accountFilter).length === 0 ||\n            Object.values(accountFilter).every((value) => !value)\n        ) {\n            this.commonLogger.warning(\n                \"getAccountInfoFilteredBy: Account filter is empty or invalid, returning null\"\n            );\n            return null;\n        }\n        const allAccounts = this.getAllAccounts(accountFilter, correlationId);\n        if (allAccounts.length > 1) {\n            // If one or more accounts are found, prioritize accounts that have an ID token\n            const sortedAccounts = allAccounts.sort((account) => {\n                return account.idTokenClaims ? -1 : 1;\n            });\n            return sortedAccounts[0];\n        } else if (allAccounts.length === 1) {\n            // If only one account is found, return it regardless of whether a matching ID token was found\n            return allAccounts[0];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns a single matching\n     * @param accountFilter\n     * @returns\n     */\n    getBaseAccountInfo(\n        accountFilter: AccountFilter,\n        correlationId: string\n    ): AccountInfo | null {\n        const accountEntities = this.getAccountsFilteredBy(\n            accountFilter,\n            correlationId\n        );\n        if (accountEntities.length > 0) {\n            return AccountEntity.getAccountInfo(accountEntities[0]);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters\n     * and builds the account info objects from the matching ID token's claims\n     * @param cachedAccounts\n     * @param accountFilter\n     * @returns Array of AccountInfo objects that match account and tenant profile filters\n     */\n    private buildTenantProfiles(\n        cachedAccounts: AccountEntity[],\n        correlationId: string,\n        accountFilter?: AccountFilter\n    ): AccountInfo[] {\n        return cachedAccounts.flatMap((accountEntity) => {\n            return this.getTenantProfilesFromAccountEntity(\n                accountEntity,\n                correlationId,\n                accountFilter?.tenantId,\n                accountFilter\n            );\n        });\n    }\n\n    private getTenantedAccountInfoByFilter(\n        accountInfo: AccountInfo,\n        tokenKeys: TokenKeys,\n        tenantProfile: TenantProfile,\n        correlationId: string,\n        tenantProfileFilter?: TenantProfileFilter\n    ): AccountInfo | null {\n        let tenantedAccountInfo: AccountInfo | null = null;\n        let idTokenClaims: TokenClaims | undefined;\n\n        if (tenantProfileFilter) {\n            if (\n                !this.tenantProfileMatchesFilter(\n                    tenantProfile,\n                    tenantProfileFilter\n                )\n            ) {\n                return null;\n            }\n        }\n\n        const idToken = this.getIdToken(\n            accountInfo,\n            correlationId,\n            tokenKeys,\n            tenantProfile.tenantId\n        );\n\n        if (idToken) {\n            idTokenClaims = extractTokenClaims(\n                idToken.secret,\n                this.cryptoImpl.base64Decode\n            );\n\n            if (\n                !this.idTokenClaimsMatchTenantProfileFilter(\n                    idTokenClaims,\n                    tenantProfileFilter\n                )\n            ) {\n                // ID token sourced claims don't match so this tenant profile is not a match\n                return null;\n            }\n        }\n\n        // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims\n        tenantedAccountInfo = updateAccountTenantProfileData(\n            accountInfo,\n            tenantProfile,\n            idTokenClaims,\n            idToken?.secret\n        );\n\n        return tenantedAccountInfo;\n    }\n\n    private getTenantProfilesFromAccountEntity(\n        accountEntity: AccountEntity,\n        correlationId: string,\n        targetTenantId?: string,\n        tenantProfileFilter?: TenantProfileFilter\n    ): AccountInfo[] {\n        const accountInfo = AccountEntity.getAccountInfo(accountEntity);\n        let searchTenantProfiles: Map<string, TenantProfile> =\n            accountInfo.tenantProfiles || new Map<string, TenantProfile>();\n        const tokenKeys = this.getTokenKeys();\n\n        // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists\n        if (targetTenantId) {\n            const tenantProfile = searchTenantProfiles.get(targetTenantId);\n            if (tenantProfile) {\n                // Reduce search field to just this tenant profile\n                searchTenantProfiles = new Map<string, TenantProfile>([\n                    [targetTenantId, tenantProfile],\n                ]);\n            } else {\n                // No tenant profile for search tenant ID, return empty array\n                return [];\n            }\n        }\n\n        const matchingTenantProfiles: AccountInfo[] = [];\n        searchTenantProfiles.forEach((tenantProfile: TenantProfile) => {\n            const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(\n                accountInfo,\n                tokenKeys,\n                tenantProfile,\n                correlationId,\n                tenantProfileFilter\n            );\n            if (tenantedAccountInfo) {\n                matchingTenantProfiles.push(tenantedAccountInfo);\n            }\n        });\n\n        return matchingTenantProfiles;\n    }\n\n    private tenantProfileMatchesFilter(\n        tenantProfile: TenantProfile,\n        tenantProfileFilter: TenantProfileFilter\n    ): boolean {\n        if (\n            !!tenantProfileFilter.localAccountId &&\n            !this.matchLocalAccountIdFromTenantProfile(\n                tenantProfile,\n                tenantProfileFilter.localAccountId\n            )\n        ) {\n            return false;\n        }\n\n        if (\n            !!tenantProfileFilter.name &&\n            !(tenantProfile.name === tenantProfileFilter.name)\n        ) {\n            return false;\n        }\n\n        if (\n            tenantProfileFilter.isHomeTenant !== undefined &&\n            !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private idTokenClaimsMatchTenantProfileFilter(\n        idTokenClaims: TokenClaims,\n        tenantProfileFilter?: TenantProfileFilter\n    ): boolean {\n        // Tenant Profile filtering\n        if (tenantProfileFilter) {\n            if (\n                !!tenantProfileFilter.localAccountId &&\n                !this.matchLocalAccountIdFromTokenClaims(\n                    idTokenClaims,\n                    tenantProfileFilter.localAccountId\n                )\n            ) {\n                return false;\n            }\n\n            if (\n                !!tenantProfileFilter.loginHint &&\n                !this.matchLoginHintFromTokenClaims(\n                    idTokenClaims,\n                    tenantProfileFilter.loginHint\n                )\n            ) {\n                return false;\n            }\n\n            if (\n                !!tenantProfileFilter.username &&\n                !this.matchUsername(\n                    idTokenClaims.preferred_username,\n                    tenantProfileFilter.username\n                )\n            ) {\n                return false;\n            }\n\n            if (\n                !!tenantProfileFilter.name &&\n                !this.matchName(idTokenClaims, tenantProfileFilter.name)\n            ) {\n                return false;\n            }\n\n            if (\n                !!tenantProfileFilter.sid &&\n                !this.matchSid(idTokenClaims, tenantProfileFilter.sid)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord {CacheRecord}\n     * @param correlationId {?string} correlation id\n     * @param kmsi - Keep Me Signed In\n     * @param storeInCache {?StoreInCache}\n     */\n    async saveCacheRecord(\n        cacheRecord: CacheRecord,\n        correlationId: string,\n        kmsi: boolean,\n        storeInCache?: StoreInCache\n    ): Promise<void> {\n        if (!cacheRecord) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.invalidCacheRecord\n            );\n        }\n\n        try {\n            if (!!cacheRecord.account) {\n                await this.setAccount(cacheRecord.account, correlationId, kmsi);\n            }\n\n            if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n                await this.setIdTokenCredential(\n                    cacheRecord.idToken,\n                    correlationId,\n                    kmsi\n                );\n            }\n\n            if (\n                !!cacheRecord.accessToken &&\n                storeInCache?.accessToken !== false\n            ) {\n                await this.saveAccessToken(\n                    cacheRecord.accessToken,\n                    correlationId,\n                    kmsi\n                );\n            }\n\n            if (\n                !!cacheRecord.refreshToken &&\n                storeInCache?.refreshToken !== false\n            ) {\n                await this.setRefreshTokenCredential(\n                    cacheRecord.refreshToken,\n                    correlationId,\n                    kmsi\n                );\n            }\n\n            if (!!cacheRecord.appMetadata) {\n                this.setAppMetadata(cacheRecord.appMetadata, correlationId);\n            }\n        } catch (e: unknown) {\n            this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);\n            if (e instanceof AuthError) {\n                throw e;\n            } else {\n                throw createCacheError(e);\n            }\n        }\n    }\n\n    /**\n     * saves access token credential\n     * @param credential\n     */\n    private async saveAccessToken(\n        credential: AccessTokenEntity,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<void> {\n        const accessTokenFilter: CredentialFilter = {\n            clientId: credential.clientId,\n            credentialType: credential.credentialType,\n            environment: credential.environment,\n            homeAccountId: credential.homeAccountId,\n            realm: credential.realm,\n            tokenType: credential.tokenType,\n            requestedClaimsHash: credential.requestedClaimsHash,\n        };\n\n        const tokenKeys = this.getTokenKeys();\n        const currentScopes = ScopeSet.fromString(credential.target);\n\n        tokenKeys.accessToken.forEach((key) => {\n            if (\n                !this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)\n            ) {\n                return;\n            }\n\n            const tokenEntity = this.getAccessTokenCredential(\n                key,\n                correlationId\n            );\n\n            if (\n                tokenEntity &&\n                this.credentialMatchesFilter(tokenEntity, accessTokenFilter)\n            ) {\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                    this.removeAccessToken(key, correlationId);\n                }\n            }\n        });\n        await this.setAccessTokenCredential(credential, correlationId, kmsi);\n    }\n\n    /**\n     * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache\n     * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param accountFilter - An object containing Account properties to filter by\n     */\n    getAccountsFilteredBy(\n        accountFilter: AccountFilter,\n        correlationId: string\n    ): AccountEntity[] {\n        const allAccountKeys = this.getAccountKeys();\n        const matchingAccounts: AccountEntity[] = [];\n        allAccountKeys.forEach((cacheKey) => {\n            const entity: AccountEntity | null = this.getAccount(\n                cacheKey,\n                correlationId\n            );\n\n            // Match base account fields\n\n            if (!entity) {\n                return;\n            }\n\n            if (\n                !!accountFilter.homeAccountId &&\n                !this.matchHomeAccountId(entity, accountFilter.homeAccountId)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.username &&\n                !this.matchUsername(entity.username, accountFilter.username)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.environment &&\n                !this.matchEnvironment(entity, accountFilter.environment)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.realm &&\n                !this.matchRealm(entity, accountFilter.realm)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.nativeAccountId &&\n                !this.matchNativeAccountId(\n                    entity,\n                    accountFilter.nativeAccountId\n                )\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.authorityType &&\n                !this.matchAuthorityType(entity, accountFilter.authorityType)\n            ) {\n                return;\n            }\n\n            // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts\n            const tenantProfileFilter: TenantProfileFilter = {\n                localAccountId: accountFilter?.localAccountId,\n                name: accountFilter?.name,\n            };\n\n            const matchingTenantProfiles = entity.tenantProfiles?.filter(\n                (tenantProfile: TenantProfile) => {\n                    return this.tenantProfileMatchesFilter(\n                        tenantProfile,\n                        tenantProfileFilter\n                    );\n                }\n            );\n\n            if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {\n                // No tenant profile for this account matches filter, don't add to list of matching accounts\n                return;\n            }\n\n            matchingAccounts.push(entity);\n        });\n\n        return matchingAccounts;\n    }\n\n    /**\n     * Returns whether or not the given credential entity matches the filter\n     * @param entity\n     * @param filter\n     * @returns\n     */\n    credentialMatchesFilter(\n        entity: ValidCredentialType,\n        filter: CredentialFilter\n    ): boolean {\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n            return false;\n        }\n\n        if (\n            !!filter.userAssertionHash &&\n            !this.matchUserAssertionHash(entity, filter.userAssertionHash)\n        ) {\n            return false;\n        }\n\n        /*\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n         * because we don't want a client_credential request to return a cached token that has a homeAccountId\n         */\n        if (\n            typeof filter.homeAccountId === \"string\" &&\n            !this.matchHomeAccountId(entity, filter.homeAccountId)\n        ) {\n            return false;\n        }\n\n        if (\n            !!filter.environment &&\n            !this.matchEnvironment(entity, filter.environment)\n        ) {\n            return false;\n        }\n\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n            return false;\n        }\n\n        if (\n            !!filter.credentialType &&\n            !this.matchCredentialType(entity, filter.credentialType)\n        ) {\n            return false;\n        }\n\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n            return false;\n        }\n\n        /*\n         * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\n         */\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n            return false;\n        }\n\n        // If request OR cached entity has requested Claims Hash, check if they match\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n            // Don't match if either is undefined or they are different\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n                return false;\n            }\n        }\n\n        // Access Token with Auth Scheme specific matching\n        if (\n            entity.credentialType ===\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\n        ) {\n            if (\n                !!filter.tokenType &&\n                !this.matchTokenType(entity, filter.tokenType)\n            ) {\n                return false;\n            }\n\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n            if (filter.tokenType === AuthenticationScheme.SSH) {\n                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n     * @param filter\n     */\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\n        const allCacheKeys = this.getKeys();\n        const matchingAppMetadata: AppMetadataCache = {};\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-appMetadata type cache entities\n            if (!this.isAppMetadata(cacheKey)) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAppMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (\n                !!filter.environment &&\n                !this.matchEnvironment(entity, filter.environment)\n            ) {\n                return;\n            }\n\n            if (\n                !!filter.clientId &&\n                !this.matchClientId(entity, filter.clientId)\n            ) {\n                return;\n            }\n\n            matchingAppMetadata[cacheKey] = entity;\n        });\n\n        return matchingAppMetadata;\n    }\n\n    /**\n     * retrieve authorityMetadata that contains a matching alias\n     * @param filter\n     */\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\n        const allCacheKeys = this.getAuthorityMetadataKeys();\n        let matchedEntity = null;\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-authorityMetadata type cache entities\n            if (\n                !this.isAuthorityMetadata(cacheKey) ||\n                cacheKey.indexOf(this.clientId) === -1\n            ) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAuthorityMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (entity.aliases.indexOf(host) === -1) {\n                return;\n            }\n\n            matchedEntity = entity;\n        });\n\n        return matchedEntity;\n    }\n\n    /**\n     * Removes all accounts and related tokens from cache.\n     */\n    removeAllAccounts(correlationId: string): void {\n        const accounts = this.getAllAccounts({}, correlationId);\n        accounts.forEach((account) => {\n            this.removeAccount(account, correlationId);\n        });\n    }\n\n    /**\n     * Removes the account and related tokens for a given account key\n     * @param account\n     */\n    removeAccount(account: AccountInfo, correlationId: string): void {\n        this.removeAccountContext(account, correlationId);\n        const accountKeys = this.getAccountKeys();\n        const keyFilter = (key: string): boolean => {\n            return (\n                key.includes(account.homeAccountId) &&\n                key.includes(account.environment)\n            );\n        };\n        accountKeys.filter(keyFilter).forEach((key) => {\n            this.removeItem(key, correlationId);\n            this.performanceClient.incrementFields(\n                { accountsRemoved: 1 },\n                correlationId\n            );\n        });\n    }\n\n    /**\n     * Removes credentials associated with the provided account\n     * @param account\n     */\n    removeAccountContext(account: AccountInfo, correlationId: string): void {\n        const allTokenKeys = this.getTokenKeys();\n        const keyFilter = (key: string): boolean => {\n            return (\n                key.includes(account.homeAccountId) &&\n                key.includes(account.environment)\n            );\n        };\n\n        allTokenKeys.idToken.filter(keyFilter).forEach((key) => {\n            this.removeIdToken(key, correlationId);\n        });\n\n        allTokenKeys.accessToken.filter(keyFilter).forEach((key) => {\n            this.removeAccessToken(key, correlationId);\n        });\n\n        allTokenKeys.refreshToken.filter(keyFilter).forEach((key) => {\n            this.removeRefreshToken(key, correlationId);\n        });\n    }\n\n    /**\n     * Removes accessToken from the cache\n     * @param key\n     * @param correlationId\n     */\n    removeAccessToken(key: string, correlationId: string): void {\n        const credential = this.getAccessTokenCredential(key, correlationId);\n        this.removeItem(key, correlationId);\n        this.performanceClient.incrementFields(\n            { accessTokensRemoved: 1 },\n            correlationId\n        );\n\n        if (\n            !credential ||\n            credential.credentialType.toLowerCase() !==\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() ||\n            credential.tokenType !== AuthenticationScheme.POP\n        ) {\n            // If the credential is not a PoP token, we can return\n            return;\n        }\n\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\n        const kid = credential.keyId;\n\n        if (kid) {\n            void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {\n                this.commonLogger.error(\n                    `Failed to remove token binding key ${kid}`,\n                    correlationId\n                );\n                this.performanceClient?.incrementFields(\n                    { removeTokenBindingKeyFailure: 1 },\n                    correlationId\n                );\n            });\n        }\n    }\n\n    /**\n     * Removes all app metadata objects from cache.\n     */\n    removeAppMetadata(correlationId: string): boolean {\n        const allCacheKeys = this.getKeys();\n        allCacheKeys.forEach((cacheKey) => {\n            if (this.isAppMetadata(cacheKey)) {\n                this.removeItem(cacheKey, correlationId);\n            }\n        });\n\n        return true;\n    }\n\n    /**\n     * Retrieve IdTokenEntity from cache\n     * @param account {AccountInfo}\n     * @param tokenKeys {?TokenKeys}\n     * @param targetRealm {?string}\n     * @param performanceClient {?IPerformanceClient}\n     * @param correlationId {?string}\n     */\n    getIdToken(\n        account: AccountInfo,\n        correlationId: string,\n        tokenKeys?: TokenKeys,\n        targetRealm?: string,\n        performanceClient?: IPerformanceClient\n    ): IdTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getIdToken called\");\n        const idTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.ID_TOKEN,\n            clientId: this.clientId,\n            realm: targetRealm,\n        };\n\n        const idTokenMap: Map<string, IdTokenEntity> = this.getIdTokensByFilter(\n            idTokenFilter,\n            correlationId,\n            tokenKeys\n        );\n\n        const numIdTokens = idTokenMap.size;\n\n        if (numIdTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n            return null;\n        } else if (numIdTokens > 1) {\n            let tokensToBeRemoved: Map<string, IdTokenEntity> = idTokenMap;\n            // Multiple tenant profiles and no tenant specified, pick home account\n            if (!targetRealm) {\n                const homeIdTokenMap: Map<string, IdTokenEntity> = new Map<\n                    string,\n                    IdTokenEntity\n                >();\n                idTokenMap.forEach((idToken, key) => {\n                    if (idToken.realm === account.tenantId) {\n                        homeIdTokenMap.set(key, idToken);\n                    }\n                });\n                const numHomeIdTokens = homeIdTokenMap.size;\n                if (numHomeIdTokens < 1) {\n                    this.commonLogger.info(\n                        \"CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result\"\n                    );\n                    return idTokenMap.values().next().value;\n                } else if (numHomeIdTokens === 1) {\n                    this.commonLogger.info(\n                        \"CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile\"\n                    );\n                    return homeIdTokenMap.values().next().value;\n                } else {\n                    // Multiple ID tokens for home tenant profile, remove all and return null\n                    tokensToBeRemoved = homeIdTokenMap;\n                }\n            }\n            // Multiple tokens for a single tenant profile, remove all and return null\n            this.commonLogger.info(\n                \"CacheManager:getIdToken - Multiple matching ID tokens found, clearing them\"\n            );\n            tokensToBeRemoved.forEach((idToken, key) => {\n                this.removeIdToken(key, correlationId);\n            });\n            if (performanceClient && correlationId) {\n                performanceClient.addFields(\n                    { multiMatchedID: idTokenMap.size },\n                    correlationId\n                );\n            }\n            return null;\n        }\n\n        this.commonLogger.info(\"CacheManager:getIdToken - Returning ID token\");\n        return idTokenMap.values().next().value;\n    }\n\n    /**\n     * Gets all idTokens matching the given filter\n     * @param filter\n     * @returns\n     */\n    getIdTokensByFilter(\n        filter: CredentialFilter,\n        correlationId: string,\n        tokenKeys?: TokenKeys\n    ): Map<string, IdTokenEntity> {\n        const idTokenKeys =\n            (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;\n\n        const idTokens: Map<string, IdTokenEntity> = new Map<\n            string,\n            IdTokenEntity\n        >();\n        idTokenKeys.forEach((key) => {\n            if (\n                !this.idTokenKeyMatchesFilter(key, {\n                    clientId: this.clientId,\n                    ...filter,\n                })\n            ) {\n                return;\n            }\n            const idToken = this.getIdTokenCredential(key, correlationId);\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n                idTokens.set(key, idToken);\n            }\n        });\n\n        return idTokens;\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     * @returns\n     */\n    idTokenKeyMatchesFilter(\n        inputKey: string,\n        filter: CredentialFilter\n    ): boolean {\n        const key = inputKey.toLowerCase();\n        if (\n            filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (\n            filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Removes idToken from the cache\n     * @param key\n     */\n    removeIdToken(key: string, correlationId: string): void {\n        this.removeItem(key, correlationId);\n    }\n\n    /**\n     * Removes refresh token from the cache\n     * @param key\n     */\n    removeRefreshToken(key: string, correlationId: string): void {\n        this.removeItem(key, correlationId);\n    }\n\n    /**\n     * Retrieve AccessTokenEntity from cache\n     * @param account {AccountInfo}\n     * @param request {BaseAuthRequest}\n     * @param correlationId {?string}\n     * @param tokenKeys {?TokenKeys}\n     * @param performanceClient {?IPerformanceClient}\n     */\n    getAccessToken(\n        account: AccountInfo,\n        request: BaseAuthRequest,\n        tokenKeys?: TokenKeys,\n        targetRealm?: string\n    ): AccessTokenEntity | null {\n        const correlationId = request.correlationId;\n        this.commonLogger.trace(\n            \"CacheManager - getAccessToken called\",\n            correlationId\n        );\n        const scopes = ScopeSet.createSearchScopes(request.scopes);\n        const authScheme =\n            request.authenticationScheme || AuthenticationScheme.BEARER;\n        /*\n         * Distinguish between Bearer and PoP/SSH token cache types\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        const credentialType =\n            authScheme &&\n            authScheme.toLowerCase() !==\n                AuthenticationScheme.BEARER.toLowerCase()\n                ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\n                : CredentialType.ACCESS_TOKEN;\n\n        const accessTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: credentialType,\n            clientId: this.clientId,\n            realm: targetRealm || account.tenantId,\n            target: scopes,\n            tokenType: authScheme,\n            keyId: request.sshKid,\n            requestedClaimsHash: request.requestedClaimsHash,\n        };\n\n        const accessTokenKeys =\n            (tokenKeys && tokenKeys.accessToken) ||\n            this.getTokenKeys().accessToken;\n        const accessTokens: AccessTokenEntity[] = [];\n\n        accessTokenKeys.forEach((key) => {\n            // Validate key\n            if (\n                this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)\n            ) {\n                const accessToken = this.getAccessTokenCredential(\n                    key,\n                    correlationId\n                );\n\n                // Validate value\n                if (\n                    accessToken &&\n                    this.credentialMatchesFilter(accessToken, accessTokenFilter)\n                ) {\n                    accessTokens.push(accessToken);\n                }\n            }\n        });\n\n        const numAccessTokens = accessTokens.length;\n        if (numAccessTokens < 1) {\n            this.commonLogger.info(\n                \"CacheManager:getAccessToken - No token found\",\n                correlationId\n            );\n            return null;\n        } else if (numAccessTokens > 1) {\n            this.commonLogger.info(\n                \"CacheManager:getAccessToken - Multiple access tokens found, clearing them\",\n                correlationId\n            );\n            accessTokens.forEach((accessToken) => {\n                this.removeAccessToken(\n                    this.generateCredentialKey(accessToken),\n                    correlationId\n                );\n            });\n            this.performanceClient.addFields(\n                { multiMatchedAT: accessTokens.length },\n                correlationId\n            );\n            return null;\n        }\n\n        this.commonLogger.info(\n            \"CacheManager:getAccessToken - Returning access token\",\n            correlationId\n        );\n        return accessTokens[0];\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     * @param keyMustContainAllScopes\n     * @returns\n     */\n    accessTokenKeyMatchesFilter(\n        inputKey: string,\n        filter: CredentialFilter,\n        keyMustContainAllScopes: boolean\n    ): boolean {\n        const key = inputKey.toLowerCase();\n        if (\n            filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (\n            filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (\n            filter.requestedClaimsHash &&\n            key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (filter.target) {\n            const scopes = filter.target.asArray();\n            for (let i = 0; i < scopes.length; i++) {\n                if (\n                    keyMustContainAllScopes &&\n                    !key.includes(scopes[i].toLowerCase())\n                ) {\n                    // When performing a cache lookup a missing scope would be a cache miss\n                    return false;\n                } else if (\n                    !keyMustContainAllScopes &&\n                    key.includes(scopes[i].toLowerCase())\n                ) {\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\n                    return true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Gets all access tokens matching the filter\n     * @param filter\n     * @returns\n     */\n    getAccessTokensByFilter(\n        filter: CredentialFilter,\n        correlationId: string\n    ): AccessTokenEntity[] {\n        const tokenKeys = this.getTokenKeys();\n\n        const accessTokens: AccessTokenEntity[] = [];\n        tokenKeys.accessToken.forEach((key) => {\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n                return;\n            }\n\n            const accessToken = this.getAccessTokenCredential(\n                key,\n                correlationId\n            );\n            if (\n                accessToken &&\n                this.credentialMatchesFilter(accessToken, filter)\n            ) {\n                accessTokens.push(accessToken);\n            }\n        });\n\n        return accessTokens;\n    }\n\n    /**\n     * Helper to retrieve the appropriate refresh token from cache\n     * @param account {AccountInfo}\n     * @param familyRT {boolean}\n     * @param correlationId {?string}\n     * @param tokenKeys {?TokenKeys}\n     * @param performanceClient {?IPerformanceClient}\n     */\n    getRefreshToken(\n        account: AccountInfo,\n        familyRT: boolean,\n        correlationId: string,\n        tokenKeys?: TokenKeys,\n        performanceClient?: IPerformanceClient\n    ): RefreshTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n        const id = familyRT ? THE_FAMILY_ID : undefined;\n        const refreshTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.REFRESH_TOKEN,\n            clientId: this.clientId,\n            familyId: id,\n        };\n\n        const refreshTokenKeys =\n            (tokenKeys && tokenKeys.refreshToken) ||\n            this.getTokenKeys().refreshToken;\n        const refreshTokens: RefreshTokenEntity[] = [];\n\n        refreshTokenKeys.forEach((key) => {\n            // Validate key\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n                const refreshToken = this.getRefreshTokenCredential(\n                    key,\n                    correlationId\n                );\n                // Validate value\n                if (\n                    refreshToken &&\n                    this.credentialMatchesFilter(\n                        refreshToken,\n                        refreshTokenFilter\n                    )\n                ) {\n                    refreshTokens.push(refreshToken);\n                }\n            }\n        });\n\n        const numRefreshTokens = refreshTokens.length;\n        if (numRefreshTokens < 1) {\n            this.commonLogger.info(\n                \"CacheManager:getRefreshToken - No refresh token found.\"\n            );\n            return null;\n        }\n        // address the else case after remove functions address environment aliases\n\n        if (numRefreshTokens > 1 && performanceClient && correlationId) {\n            performanceClient.addFields(\n                { multiMatchedRT: numRefreshTokens },\n                correlationId\n            );\n        }\n\n        this.commonLogger.info(\n            \"CacheManager:getRefreshToken - returning refresh token\"\n        );\n        return refreshTokens[0] as RefreshTokenEntity;\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     */\n    refreshTokenKeyMatchesFilter(\n        inputKey: string,\n        filter: CredentialFilter\n    ): boolean {\n        const key = inputKey.toLowerCase();\n        if (\n            filter.familyId &&\n            key.indexOf(filter.familyId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        // If familyId is used, clientId is not in the key\n        if (\n            !filter.familyId &&\n            filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (\n            filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Retrieve AppMetadataEntity from cache\n     */\n    readAppMetadataFromCache(environment: string): AppMetadataEntity | null {\n        const appMetadataFilter: AppMetadataFilter = {\n            environment,\n            clientId: this.clientId,\n        };\n\n        const appMetadata: AppMetadataCache =\n            this.getAppMetadataFilteredBy(appMetadataFilter);\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(\n            appMetadata\n        ).map((key) => appMetadata[key]);\n\n        const numAppMetadata = appMetadataEntries.length;\n        if (numAppMetadata < 1) {\n            return null;\n        } else if (numAppMetadata > 1) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.multipleMatchingAppMetadata\n            );\n        }\n\n        return appMetadataEntries[0] as AppMetadataEntity;\n    }\n\n    /**\n     * Return the family_id value associated  with FOCI\n     * @param environment\n     * @param clientId\n     */\n    isAppMetadataFOCI(environment: string): boolean {\n        const appMetadata = this.readAppMetadataFromCache(environment);\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n    }\n\n    /**\n     * helper to match account ids\n     * @param value\n     * @param homeAccountId\n     */\n    private matchHomeAccountId(\n        entity: AccountEntity | CredentialEntity,\n        homeAccountId: string\n    ): boolean {\n        return !!(\n            typeof entity.homeAccountId === \"string\" &&\n            homeAccountId === entity.homeAccountId\n        );\n    }\n\n    /**\n     * helper to match account ids\n     * @param entity\n     * @param localAccountId\n     * @returns\n     */\n    private matchLocalAccountIdFromTokenClaims(\n        tokenClaims: TokenClaims,\n        localAccountId: string\n    ): boolean {\n        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;\n        return localAccountId === idTokenLocalAccountId;\n    }\n\n    private matchLocalAccountIdFromTenantProfile(\n        tenantProfile: TenantProfile,\n        localAccountId: string\n    ): boolean {\n        return tenantProfile.localAccountId === localAccountId;\n    }\n\n    /**\n     * helper to match names\n     * @param entity\n     * @param name\n     * @returns true if the downcased name properties are present and match in the filter and the entity\n     */\n    private matchName(claims: TokenClaims, name: string): boolean {\n        return !!(name.toLowerCase() === claims.name?.toLowerCase());\n    }\n\n    /**\n     * helper to match usernames\n     * @param entity\n     * @param username\n     * @returns\n     */\n    private matchUsername(\n        cachedUsername?: string,\n        filterUsername?: string\n    ): boolean {\n        return !!(\n            cachedUsername &&\n            typeof cachedUsername === \"string\" &&\n            filterUsername?.toLowerCase() === cachedUsername.toLowerCase()\n        );\n    }\n\n    /**\n     * helper to match assertion\n     * @param value\n     * @param oboAssertion\n     */\n    private matchUserAssertionHash(\n        entity: CredentialEntity,\n        userAssertionHash: string\n    ): boolean {\n        return !!(\n            entity.userAssertionHash &&\n            userAssertionHash === entity.userAssertionHash\n        );\n    }\n\n    /**\n     * helper to match environment\n     * @param value\n     * @param environment\n     */\n    private matchEnvironment(\n        entity: AccountEntity | CredentialEntity | AppMetadataEntity,\n        environment: string\n    ): boolean {\n        // Check static authority options first for cases where authority metadata has not been resolved and cached yet\n        if (this.staticAuthorityOptions) {\n            const staticAliases = getAliasesFromStaticSources(\n                this.staticAuthorityOptions,\n                this.commonLogger\n            );\n            if (\n                staticAliases.includes(environment) &&\n                staticAliases.includes(entity.environment)\n            ) {\n                return true;\n            }\n        }\n\n        // Query metadata cache if no static authority configuration has aliases that match enviroment\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n        if (\n            cloudMetadata &&\n            cloudMetadata.aliases.indexOf(entity.environment) > -1\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * helper to match credential type\n     * @param entity\n     * @param credentialType\n     */\n    private matchCredentialType(\n        entity: CredentialEntity,\n        credentialType: string\n    ): boolean {\n        return (\n            entity.credentialType &&\n            credentialType.toLowerCase() === entity.credentialType.toLowerCase()\n        );\n    }\n\n    /**\n     * helper to match client ids\n     * @param entity\n     * @param clientId\n     */\n    private matchClientId(\n        entity: CredentialEntity | AppMetadataEntity,\n        clientId: string\n    ): boolean {\n        return !!(entity.clientId && clientId === entity.clientId);\n    }\n\n    /**\n     * helper to match family ids\n     * @param entity\n     * @param familyId\n     */\n    private matchFamilyId(\n        entity: CredentialEntity | AppMetadataEntity,\n        familyId: string\n    ): boolean {\n        return !!(entity.familyId && familyId === entity.familyId);\n    }\n\n    /**\n     * helper to match realm\n     * @param entity\n     * @param realm\n     */\n    private matchRealm(\n        entity: AccountEntity | CredentialEntity,\n        realm: string\n    ): boolean {\n        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());\n    }\n\n    /**\n     * helper to match nativeAccountId\n     * @param entity\n     * @param nativeAccountId\n     * @returns boolean indicating the match result\n     */\n    private matchNativeAccountId(\n        entity: AccountEntity,\n        nativeAccountId: string\n    ): boolean {\n        return !!(\n            entity.nativeAccountId && nativeAccountId === entity.nativeAccountId\n        );\n    }\n\n    /**\n     * helper to match loginHint which can be either:\n     * 1. login_hint ID token claim\n     * 2. username in cached account object\n     * 3. upn in ID token claims\n     * @param entity\n     * @param loginHint\n     * @returns\n     */\n    private matchLoginHintFromTokenClaims(\n        tokenClaims: TokenClaims,\n        loginHint: string\n    ): boolean {\n        if (tokenClaims.login_hint === loginHint) {\n            return true;\n        }\n\n        if (tokenClaims.preferred_username === loginHint) {\n            return true;\n        }\n\n        if (tokenClaims.upn === loginHint) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper to match sid\n     * @param entity\n     * @param sid\n     * @returns true if the sid claim is present and matches the filter\n     */\n    private matchSid(idTokenClaims: TokenClaims, sid: string): boolean {\n        return idTokenClaims.sid === sid;\n    }\n\n    private matchAuthorityType(\n        entity: AccountEntity,\n        authorityType: string\n    ): boolean {\n        return !!(\n            entity.authorityType &&\n            authorityType.toLowerCase() === entity.authorityType.toLowerCase()\n        );\n    }\n\n    /**\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n     * @param entity\n     * @param target\n     */\n    private matchTarget(entity: CredentialEntity, target: ScopeSet): boolean {\n        const isNotAccessTokenCredential =\n            entity.credentialType !== CredentialType.ACCESS_TOKEN &&\n            entity.credentialType !==\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n        if (isNotAccessTokenCredential || !entity.target) {\n            return false;\n        }\n\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\n\n        return entityScopeSet.containsScopeSet(target);\n    }\n\n    /**\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    private matchTokenType(\n        entity: CredentialEntity,\n        tokenType: AuthenticationScheme\n    ): boolean {\n        return !!(entity.tokenType && entity.tokenType === tokenType);\n    }\n\n    /**\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\n     * @param entity\n     * @param keyId\n     */\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\n        return !!(entity.keyId && entity.keyId === keyId);\n    }\n\n    /**\n     * returns if a given cache entity is of the type appmetadata\n     * @param key\n     */\n    private isAppMetadata(key: string): boolean {\n        return key.indexOf(APP_METADATA) !== -1;\n    }\n\n    /**\n     * returns if a given cache entity is of the type authoritymetadata\n     * @param key\n     */\n    protected isAuthorityMetadata(key: string): boolean {\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n    }\n\n    /**\n     * returns cache key used for cloud instance metadata\n     */\n    generateAuthorityMetadataCacheKey(authority: string): string {\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n    }\n\n    /**\n     * Helper to convert serialized data to object\n     * @param obj\n     * @param json\n     */\n    static toObject<T>(obj: T, json: object): T {\n        for (const propertyName in json) {\n            obj[propertyName] = json[propertyName];\n        }\n        return obj;\n    }\n}\n\n/** @internal */\nexport class DefaultStorageClass extends CacheManager {\n    async setAccount(): Promise<void> {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAccount(): AccountEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    async setIdTokenCredential(): Promise<void> {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getIdTokenCredential(): IdTokenEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    async setAccessTokenCredential(): Promise<void> {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAccessTokenCredential(): AccessTokenEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    async setRefreshTokenCredential(): Promise<void> {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getRefreshTokenCredential(): RefreshTokenEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setAppMetadata(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAppMetadata(): AppMetadataEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setServerTelemetry(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getServerTelemetry(): ServerTelemetryEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setAuthorityMetadata(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAuthorityMetadataKeys(): Array<string> {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setThrottlingCache(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getThrottlingCache(): ThrottlingEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    removeItem(): boolean {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getKeys(): string[] {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAccountKeys(): string[] {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getTokenKeys(): TokenKeys {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    generateCredentialKey(): string {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    generateAccountKey(): string {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}