{"ast":null,"code":"/*! @azure/msal-browser v4.26.2 2025-11-19 */\n'use strict';\n\nimport { AuthToken, Authority, AccountEntity, buildAccountToCache, CacheHelpers, ScopeSet, TimeUtils } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { createNewGuid } from '../crypto/BrowserCrypto.mjs';\nimport { nonBrowserEnvironment, unableToLoadToken } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Token cache manager\r\n */\nclass TokenCache {\n  constructor(configuration, storage, logger, cryptoObj) {\n    this.isBrowserEnvironment = typeof window !== \"undefined\";\n    this.config = configuration;\n    this.storage = storage;\n    this.logger = logger;\n    this.cryptoObj = cryptoObj;\n  }\n  // Move getAllAccounts here and cache utility APIs\n  /**\r\n   * API to load tokens to msal-browser cache.\r\n   * @param request\r\n   * @param response\r\n   * @param options\r\n   * @returns `AuthenticationResult` for the response that was loaded.\r\n   */\n  async loadExternalTokens(request, response, options) {\n    if (!this.isBrowserEnvironment) {\n      throw createBrowserAuthError(nonBrowserEnvironment);\n    }\n    const correlationId = request.correlationId || createNewGuid();\n    const idTokenClaims = response.id_token ? AuthToken.extractTokenClaims(response.id_token, base64Decode) : undefined;\n    const kmsi = AuthToken.isKmsi(idTokenClaims || {});\n    const authorityOptions = {\n      protocolMode: this.config.auth.protocolMode,\n      knownAuthorities: this.config.auth.knownAuthorities,\n      cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n      authorityMetadata: this.config.auth.authorityMetadata,\n      skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache\n    };\n    const authority = request.authority ? new Authority(Authority.generateAuthority(request.authority, request.azureCloudOptions), this.config.system.networkClient, this.storage, authorityOptions, this.logger, request.correlationId || createNewGuid()) : undefined;\n    const cacheRecordAccount = await this.loadAccount(request, options.clientInfo || response.client_info || \"\", correlationId, idTokenClaims, authority);\n    const idToken = await this.loadIdToken(response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, cacheRecordAccount.realm, correlationId, kmsi);\n    const accessToken = await this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, cacheRecordAccount.realm, options, correlationId, kmsi);\n    const refreshToken = await this.loadRefreshToken(response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, correlationId, kmsi);\n    return this.generateAuthenticationResult(request, {\n      account: cacheRecordAccount,\n      idToken,\n      accessToken,\n      refreshToken\n    }, idTokenClaims, authority);\n  }\n  /**\r\n   * Helper function to load account to msal-browser cache\r\n   * @param idToken\r\n   * @param environment\r\n   * @param clientInfo\r\n   * @param authorityType\r\n   * @param requestHomeAccountId\r\n   * @returns `AccountEntity`\r\n   */\n  async loadAccount(request, clientInfo, correlationId, idTokenClaims, authority) {\n    this.logger.verbose(\"TokenCache - loading account\");\n    if (request.account) {\n      const accountEntity = AccountEntity.createFromAccountInfo(request.account);\n      await this.storage.setAccount(accountEntity, correlationId, AuthToken.isKmsi(idTokenClaims || {}));\n      return accountEntity;\n    } else if (!authority || !clientInfo && !idTokenClaims) {\n      this.logger.error(\"TokenCache - if an account is not provided on the request, authority and either clientInfo or idToken must be provided instead.\");\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    const homeAccountId = AccountEntity.generateHomeAccountId(clientInfo, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\n    const claimsTenantId = idTokenClaims === null || idTokenClaims === void 0 ? void 0 : idTokenClaims.tid;\n    const cachedAccount = buildAccountToCache(this.storage, authority, homeAccountId, base64Decode, correlationId, idTokenClaims, clientInfo, authority.hostnameAndPort, claimsTenantId, undefined,\n    // authCodePayload\n    undefined,\n    // nativeAccountId\n    this.logger);\n    await this.storage.setAccount(cachedAccount, correlationId, AuthToken.isKmsi(idTokenClaims || {}));\n    return cachedAccount;\n  }\n  /**\r\n   * Helper function to load id tokens to msal-browser cache\r\n   * @param idToken\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param tenantId\r\n   * @returns `IdTokenEntity`\r\n   */\n  async loadIdToken(response, homeAccountId, environment, tenantId, correlationId, kmsi) {\n    if (!response.id_token) {\n      this.logger.verbose(\"TokenCache - no id token found in response\");\n      return null;\n    }\n    this.logger.verbose(\"TokenCache - loading id token\");\n    const idTokenEntity = CacheHelpers.createIdTokenEntity(homeAccountId, environment, response.id_token, this.config.auth.clientId, tenantId);\n    await this.storage.setIdTokenCredential(idTokenEntity, correlationId, kmsi);\n    return idTokenEntity;\n  }\n  /**\r\n   * Helper function to load access tokens to msal-browser cache\r\n   * @param request\r\n   * @param response\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param tenantId\r\n   * @returns `AccessTokenEntity`\r\n   */\n  async loadAccessToken(request, response, homeAccountId, environment, tenantId, options, correlationId, kmsi) {\n    if (!response.access_token) {\n      this.logger.verbose(\"TokenCache - no access token found in response\");\n      return null;\n    } else if (!response.expires_in) {\n      this.logger.error(\"TokenCache - no expiration set on the access token. Cannot add it to the cache.\");\n      return null;\n    } else if (!response.scope && (!request.scopes || !request.scopes.length)) {\n      this.logger.error(\"TokenCache - scopes not specified in the request or response. Cannot add token to the cache.\");\n      return null;\n    }\n    this.logger.verbose(\"TokenCache - loading access token\");\n    const scopes = response.scope ? ScopeSet.fromString(response.scope) : new ScopeSet(request.scopes);\n    const expiresOn = options.expiresOn || response.expires_in + TimeUtils.nowSeconds();\n    const extendedExpiresOn = options.extendedExpiresOn || (response.ext_expires_in || response.expires_in) + TimeUtils.nowSeconds();\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity(homeAccountId, environment, response.access_token, this.config.auth.clientId, tenantId, scopes.printScopes(), expiresOn, extendedExpiresOn, base64Decode);\n    await this.storage.setAccessTokenCredential(accessTokenEntity, correlationId, kmsi);\n    return accessTokenEntity;\n  }\n  /**\r\n   * Helper function to load refresh tokens to msal-browser cache\r\n   * @param request\r\n   * @param response\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @returns `RefreshTokenEntity`\r\n   */\n  async loadRefreshToken(response, homeAccountId, environment, correlationId, kmsi) {\n    if (!response.refresh_token) {\n      this.logger.verbose(\"TokenCache - no refresh token found in response\");\n      return null;\n    }\n    this.logger.verbose(\"TokenCache - loading refresh token\");\n    const refreshTokenEntity = CacheHelpers.createRefreshTokenEntity(homeAccountId, environment, response.refresh_token, this.config.auth.clientId, response.foci, undefined,\n    // userAssertionHash\n    response.refresh_token_expires_in);\n    await this.storage.setRefreshTokenCredential(refreshTokenEntity, correlationId, kmsi);\n    return refreshTokenEntity;\n  }\n  /**\r\n   * Helper function to generate an `AuthenticationResult` for the result.\r\n   * @param request\r\n   * @param idTokenObj\r\n   * @param cacheRecord\r\n   * @param authority\r\n   * @returns `AuthenticationResult`\r\n   */\n  generateAuthenticationResult(request, cacheRecord, idTokenClaims, authority) {\n    var _cacheRecord$idToken, _cacheRecord$refreshT, _cacheRecord$accessTo;\n    let accessToken = \"\";\n    let responseScopes = [];\n    let expiresOn = null;\n    let extExpiresOn;\n    if (cacheRecord !== null && cacheRecord !== void 0 && cacheRecord.accessToken) {\n      accessToken = cacheRecord.accessToken.secret;\n      responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n      // Access token expiresOn stored in seconds, converting to Date for AuthenticationResult\n      expiresOn = TimeUtils.toDateFromSeconds(cacheRecord.accessToken.expiresOn);\n      extExpiresOn = TimeUtils.toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);\n    }\n    const accountEntity = cacheRecord.account;\n    return {\n      authority: authority ? authority.canonicalAuthority : \"\",\n      uniqueId: cacheRecord.account.localAccountId,\n      tenantId: cacheRecord.account.realm,\n      scopes: responseScopes,\n      account: AccountEntity.getAccountInfo(accountEntity),\n      idToken: ((_cacheRecord$idToken = cacheRecord.idToken) === null || _cacheRecord$idToken === void 0 ? void 0 : _cacheRecord$idToken.secret) || \"\",\n      idTokenClaims: idTokenClaims || {},\n      accessToken: accessToken,\n      fromCache: true,\n      expiresOn: expiresOn,\n      correlationId: request.correlationId || \"\",\n      requestId: \"\",\n      extExpiresOn: extExpiresOn,\n      familyId: ((_cacheRecord$refreshT = cacheRecord.refreshToken) === null || _cacheRecord$refreshT === void 0 ? void 0 : _cacheRecord$refreshT.familyId) || \"\",\n      tokenType: (cacheRecord === null || cacheRecord === void 0 || (_cacheRecord$accessTo = cacheRecord.accessToken) === null || _cacheRecord$accessTo === void 0 ? void 0 : _cacheRecord$accessTo.tokenType) || \"\",\n      state: request.state || \"\",\n      cloudGraphHostName: accountEntity.cloudGraphHostName || \"\",\n      msGraphHost: accountEntity.msGraphHost || \"\",\n      fromNativeBroker: false\n    };\n  }\n}\nexport { TokenCache };","map":{"version":3,"names":["TokenCache","constructor","configuration","storage","logger","cryptoObj","isBrowserEnvironment","window","config","loadExternalTokens","request","response","options","createBrowserAuthError","nonBrowserEnvironment","correlationId","createNewGuid","idTokenClaims","id_token","AuthToken","extractTokenClaims","base64Decode","undefined","kmsi","isKmsi","authorityOptions","protocolMode","auth","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","skipAuthorityMetadataCache","authority","Authority","generateAuthority","azureCloudOptions","system","networkClient","cacheRecordAccount","loadAccount","clientInfo","client_info","idToken","loadIdToken","homeAccountId","environment","realm","accessToken","loadAccessToken","refreshToken","loadRefreshToken","generateAuthenticationResult","account","verbose","accountEntity","AccountEntity","createFromAccountInfo","setAccount","error","unableToLoadToken","generateHomeAccountId","authorityType","claimsTenantId","tid","cachedAccount","buildAccountToCache","hostnameAndPort","tenantId","idTokenEntity","CacheHelpers","createIdTokenEntity","clientId","setIdTokenCredential","access_token","expires_in","scope","scopes","length","ScopeSet","fromString","expiresOn","TimeUtils","nowSeconds","extendedExpiresOn","ext_expires_in","accessTokenEntity","createAccessTokenEntity","printScopes","setAccessTokenCredential","refresh_token","refreshTokenEntity","createRefreshTokenEntity","foci","refresh_token_expires_in","setRefreshTokenCredential","cacheRecord","_cacheRecord$idToken","_cacheRecord$refreshT","_cacheRecord$accessTo","responseScopes","extExpiresOn","secret","target","asArray","toDateFromSeconds","canonicalAuthority","uniqueId","localAccountId","getAccountInfo","fromCache","requestId","familyId","tokenType","state","cloudGraphHostName","msGraphHost","fromNativeBroker"],"sources":["/Users/tolu/pangram-cos-350/frontend/node_modules/@azure/msal-browser/src/cache/TokenCache.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccessTokenEntity,\n    ICrypto,\n    IdTokenEntity,\n    Logger,\n    ScopeSet,\n    Authority,\n    AuthorityOptions,\n    ExternalTokenResponse,\n    AccountEntity,\n    AuthToken,\n    RefreshTokenEntity,\n    CacheRecord,\n    TokenClaims,\n    CacheHelpers,\n    buildAccountToCache,\n    TimeUtils,\n} from \"@azure/msal-common/browser\";\nimport { BrowserConfiguration } from \"../config/Configuration.js\";\nimport type { SilentRequest } from \"../request/SilentRequest.js\";\nimport { BrowserCacheManager } from \"./BrowserCacheManager.js\";\nimport type { ITokenCache } from \"./ITokenCache.js\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError.js\";\nimport type { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { base64Decode } from \"../encode/Base64Decode.js\";\nimport * as BrowserCrypto from \"../crypto/BrowserCrypto.js\";\n\nexport type LoadTokenOptions = {\n    clientInfo?: string;\n    expiresOn?: number;\n    extendedExpiresOn?: number;\n};\n\n/**\n * Token cache manager\n */\nexport class TokenCache implements ITokenCache {\n    // Flag to indicate if in browser environment\n    public isBrowserEnvironment: boolean;\n    // Input configuration by developer/user\n    protected config: BrowserConfiguration;\n    // Browser cache storage\n    private storage: BrowserCacheManager;\n    // Logger\n    private logger: Logger;\n    // Crypto class\n    private cryptoObj: ICrypto;\n\n    constructor(\n        configuration: BrowserConfiguration,\n        storage: BrowserCacheManager,\n        logger: Logger,\n        cryptoObj: ICrypto\n    ) {\n        this.isBrowserEnvironment = typeof window !== \"undefined\";\n        this.config = configuration;\n        this.storage = storage;\n        this.logger = logger;\n        this.cryptoObj = cryptoObj;\n    }\n\n    // Move getAllAccounts here and cache utility APIs\n\n    /**\n     * API to load tokens to msal-browser cache.\n     * @param request\n     * @param response\n     * @param options\n     * @returns `AuthenticationResult` for the response that was loaded.\n     */\n    async loadExternalTokens(\n        request: SilentRequest,\n        response: ExternalTokenResponse,\n        options: LoadTokenOptions\n    ): Promise<AuthenticationResult> {\n        if (!this.isBrowserEnvironment) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.nonBrowserEnvironment\n            );\n        }\n\n        const correlationId =\n            request.correlationId || BrowserCrypto.createNewGuid();\n\n        const idTokenClaims = response.id_token\n            ? AuthToken.extractTokenClaims(response.id_token, base64Decode)\n            : undefined;\n        const kmsi = AuthToken.isKmsi(idTokenClaims || {});\n\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n            skipAuthorityMetadataCache:\n                this.config.auth.skipAuthorityMetadataCache,\n        };\n        const authority = request.authority\n            ? new Authority(\n                  Authority.generateAuthority(\n                      request.authority,\n                      request.azureCloudOptions\n                  ),\n                  this.config.system.networkClient,\n                  this.storage,\n                  authorityOptions,\n                  this.logger,\n                  request.correlationId || BrowserCrypto.createNewGuid()\n              )\n            : undefined;\n\n        const cacheRecordAccount: AccountEntity = await this.loadAccount(\n            request,\n            options.clientInfo || response.client_info || \"\",\n            correlationId,\n            idTokenClaims,\n            authority\n        );\n\n        const idToken = await this.loadIdToken(\n            response,\n            cacheRecordAccount.homeAccountId,\n            cacheRecordAccount.environment,\n            cacheRecordAccount.realm,\n            correlationId,\n            kmsi\n        );\n\n        const accessToken = await this.loadAccessToken(\n            request,\n            response,\n            cacheRecordAccount.homeAccountId,\n            cacheRecordAccount.environment,\n            cacheRecordAccount.realm,\n            options,\n            correlationId,\n            kmsi\n        );\n\n        const refreshToken = await this.loadRefreshToken(\n            response,\n            cacheRecordAccount.homeAccountId,\n            cacheRecordAccount.environment,\n            correlationId,\n            kmsi\n        );\n\n        return this.generateAuthenticationResult(\n            request,\n            {\n                account: cacheRecordAccount,\n                idToken,\n                accessToken,\n                refreshToken,\n            },\n            idTokenClaims,\n            authority\n        );\n    }\n\n    /**\n     * Helper function to load account to msal-browser cache\n     * @param idToken\n     * @param environment\n     * @param clientInfo\n     * @param authorityType\n     * @param requestHomeAccountId\n     * @returns `AccountEntity`\n     */\n    private async loadAccount(\n        request: SilentRequest,\n        clientInfo: string,\n        correlationId: string,\n        idTokenClaims?: TokenClaims,\n        authority?: Authority\n    ): Promise<AccountEntity> {\n        this.logger.verbose(\"TokenCache - loading account\");\n\n        if (request.account) {\n            const accountEntity = AccountEntity.createFromAccountInfo(\n                request.account\n            );\n            await this.storage.setAccount(\n                accountEntity,\n                correlationId,\n                AuthToken.isKmsi(idTokenClaims || {})\n            );\n            return accountEntity;\n        } else if (!authority || (!clientInfo && !idTokenClaims)) {\n            this.logger.error(\n                \"TokenCache - if an account is not provided on the request, authority and either clientInfo or idToken must be provided instead.\"\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n\n        const homeAccountId = AccountEntity.generateHomeAccountId(\n            clientInfo,\n            authority.authorityType,\n            this.logger,\n            this.cryptoObj,\n            idTokenClaims\n        );\n\n        const claimsTenantId = idTokenClaims?.tid;\n\n        const cachedAccount = buildAccountToCache(\n            this.storage,\n            authority,\n            homeAccountId,\n            base64Decode,\n            correlationId,\n            idTokenClaims,\n            clientInfo,\n            authority.hostnameAndPort,\n            claimsTenantId,\n            undefined, // authCodePayload\n            undefined, // nativeAccountId\n            this.logger\n        );\n\n        await this.storage.setAccount(\n            cachedAccount,\n            correlationId,\n            AuthToken.isKmsi(idTokenClaims || {})\n        );\n        return cachedAccount;\n    }\n\n    /**\n     * Helper function to load id tokens to msal-browser cache\n     * @param idToken\n     * @param homeAccountId\n     * @param environment\n     * @param tenantId\n     * @returns `IdTokenEntity`\n     */\n    private async loadIdToken(\n        response: ExternalTokenResponse,\n        homeAccountId: string,\n        environment: string,\n        tenantId: string,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<IdTokenEntity | null> {\n        if (!response.id_token) {\n            this.logger.verbose(\"TokenCache - no id token found in response\");\n            return null;\n        }\n\n        this.logger.verbose(\"TokenCache - loading id token\");\n        const idTokenEntity = CacheHelpers.createIdTokenEntity(\n            homeAccountId,\n            environment,\n            response.id_token,\n            this.config.auth.clientId,\n            tenantId\n        );\n\n        await this.storage.setIdTokenCredential(\n            idTokenEntity,\n            correlationId,\n            kmsi\n        );\n        return idTokenEntity;\n    }\n\n    /**\n     * Helper function to load access tokens to msal-browser cache\n     * @param request\n     * @param response\n     * @param homeAccountId\n     * @param environment\n     * @param tenantId\n     * @returns `AccessTokenEntity`\n     */\n    private async loadAccessToken(\n        request: SilentRequest,\n        response: ExternalTokenResponse,\n        homeAccountId: string,\n        environment: string,\n        tenantId: string,\n        options: LoadTokenOptions,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<AccessTokenEntity | null> {\n        if (!response.access_token) {\n            this.logger.verbose(\n                \"TokenCache - no access token found in response\"\n            );\n            return null;\n        } else if (!response.expires_in) {\n            this.logger.error(\n                \"TokenCache - no expiration set on the access token. Cannot add it to the cache.\"\n            );\n            return null;\n        } else if (\n            !response.scope &&\n            (!request.scopes || !request.scopes.length)\n        ) {\n            this.logger.error(\n                \"TokenCache - scopes not specified in the request or response. Cannot add token to the cache.\"\n            );\n            return null;\n        }\n\n        this.logger.verbose(\"TokenCache - loading access token\");\n\n        const scopes = response.scope\n            ? ScopeSet.fromString(response.scope)\n            : new ScopeSet(request.scopes);\n        const expiresOn =\n            options.expiresOn || response.expires_in + TimeUtils.nowSeconds();\n\n        const extendedExpiresOn =\n            options.extendedExpiresOn ||\n            (response.ext_expires_in || response.expires_in) +\n                TimeUtils.nowSeconds();\n\n        const accessTokenEntity = CacheHelpers.createAccessTokenEntity(\n            homeAccountId,\n            environment,\n            response.access_token,\n            this.config.auth.clientId,\n            tenantId,\n            scopes.printScopes(),\n            expiresOn,\n            extendedExpiresOn,\n            base64Decode\n        );\n\n        await this.storage.setAccessTokenCredential(\n            accessTokenEntity,\n            correlationId,\n            kmsi\n        );\n        return accessTokenEntity;\n    }\n\n    /**\n     * Helper function to load refresh tokens to msal-browser cache\n     * @param request\n     * @param response\n     * @param homeAccountId\n     * @param environment\n     * @returns `RefreshTokenEntity`\n     */\n    private async loadRefreshToken(\n        response: ExternalTokenResponse,\n        homeAccountId: string,\n        environment: string,\n        correlationId: string,\n        kmsi: boolean\n    ): Promise<RefreshTokenEntity | null> {\n        if (!response.refresh_token) {\n            this.logger.verbose(\n                \"TokenCache - no refresh token found in response\"\n            );\n            return null;\n        }\n\n        this.logger.verbose(\"TokenCache - loading refresh token\");\n        const refreshTokenEntity = CacheHelpers.createRefreshTokenEntity(\n            homeAccountId,\n            environment,\n            response.refresh_token,\n            this.config.auth.clientId,\n            response.foci,\n            undefined, // userAssertionHash\n            response.refresh_token_expires_in\n        );\n\n        await this.storage.setRefreshTokenCredential(\n            refreshTokenEntity,\n            correlationId,\n            kmsi\n        );\n        return refreshTokenEntity;\n    }\n\n    /**\n     * Helper function to generate an `AuthenticationResult` for the result.\n     * @param request\n     * @param idTokenObj\n     * @param cacheRecord\n     * @param authority\n     * @returns `AuthenticationResult`\n     */\n    private generateAuthenticationResult(\n        request: SilentRequest,\n        cacheRecord: CacheRecord & { account: AccountEntity },\n        idTokenClaims?: TokenClaims,\n        authority?: Authority\n    ): AuthenticationResult {\n        let accessToken: string = \"\";\n        let responseScopes: Array<string> = [];\n        let expiresOn: Date | null = null;\n        let extExpiresOn: Date | undefined;\n\n        if (cacheRecord?.accessToken) {\n            accessToken = cacheRecord.accessToken.secret;\n            responseScopes = ScopeSet.fromString(\n                cacheRecord.accessToken.target\n            ).asArray();\n            // Access token expiresOn stored in seconds, converting to Date for AuthenticationResult\n            expiresOn = TimeUtils.toDateFromSeconds(\n                cacheRecord.accessToken.expiresOn\n            );\n            extExpiresOn = TimeUtils.toDateFromSeconds(\n                cacheRecord.accessToken.extendedExpiresOn\n            );\n        }\n\n        const accountEntity = cacheRecord.account;\n\n        return {\n            authority: authority ? authority.canonicalAuthority : \"\",\n            uniqueId: cacheRecord.account.localAccountId,\n            tenantId: cacheRecord.account.realm,\n            scopes: responseScopes,\n            account: AccountEntity.getAccountInfo(accountEntity),\n            idToken: cacheRecord.idToken?.secret || \"\",\n            idTokenClaims: idTokenClaims || {},\n            accessToken: accessToken,\n            fromCache: true,\n            expiresOn: expiresOn,\n            correlationId: request.correlationId || \"\",\n            requestId: \"\",\n            extExpiresOn: extExpiresOn,\n            familyId: cacheRecord.refreshToken?.familyId || \"\",\n            tokenType: cacheRecord?.accessToken?.tokenType || \"\",\n            state: request.state || \"\",\n            cloudGraphHostName: accountEntity.cloudGraphHostName || \"\",\n            msGraphHost: accountEntity.msGraphHost || \"\",\n            fromNativeBroker: false,\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}