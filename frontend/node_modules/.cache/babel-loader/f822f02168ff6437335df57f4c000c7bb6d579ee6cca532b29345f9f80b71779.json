{"ast":null,"code":"/*! @azure/msal-common v15.13.2 2025-11-19 */\n'use strict';\n\nimport { Constants, HttpStatus, RegionDiscoverySources } from '../utils/Constants.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass RegionDiscovery {\n  constructor(networkInterface, logger, performanceClient, correlationId) {\n    this.networkInterface = networkInterface;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n  }\n  /**\r\n   * Detect the region from the application's environment.\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  async detectRegion(environmentRegion, regionDiscoveryMetadata) {\n    var _this$performanceClie;\n    (_this$performanceClie = this.performanceClient) === null || _this$performanceClie === void 0 || _this$performanceClie.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n    // Initialize auto detected region with the region from the envrionment\n    let autodetectedRegionName = environmentRegion;\n    // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n    if (!autodetectedRegionName) {\n      const options = RegionDiscovery.IMDS_OPTIONS;\n      try {\n        const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);\n        if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {\n          autodetectedRegionName = localIMDSVersionResponse.body;\n          regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n        }\n        // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n        if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {\n          const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);\n          if (!currentIMDSVersion) {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return null;\n          }\n          const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);\n          if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {\n            autodetectedRegionName = currentIMDSVersionResponse.body;\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n          }\n        }\n      } catch (e) {\n        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        return null;\n      }\n    } else {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n    }\n    // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n    if (!autodetectedRegionName) {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n    }\n    return autodetectedRegionName || null;\n  }\n  /**\r\n   * Make the call to the IMDS endpoint\r\n   *\r\n   * @param imdsEndpointUrl\r\n   * @returns Promise<NetworkResponse<string>>\r\n   */\n  async getRegionFromIMDS(version, options) {\n    var _this$performanceClie2;\n    (_this$performanceClie2 = this.performanceClient) === null || _this$performanceClie2 === void 0 || _this$performanceClie2.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n    return this.networkInterface.sendGetRequestAsync(\"\".concat(Constants.IMDS_ENDPOINT, \"?api-version=\").concat(version, \"&format=text\"), options, Constants.IMDS_TIMEOUT);\n  }\n  /**\r\n   * Get the most recent version of the IMDS endpoint available\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  async getCurrentVersion(options) {\n    var _this$performanceClie3;\n    (_this$performanceClie3 = this.performanceClient) === null || _this$performanceClie3 === void 0 || _this$performanceClie3.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n    try {\n      const response = await this.networkInterface.sendGetRequestAsync(\"\".concat(Constants.IMDS_ENDPOINT, \"?format=json\"), options);\n      // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n      if (response.status === HttpStatus.BAD_REQUEST && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n        return response.body[\"newest-versions\"][0];\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n// Options for the IMDS endpoint request\nRegionDiscovery.IMDS_OPTIONS = {\n  headers: {\n    Metadata: \"true\"\n  }\n};\nexport { RegionDiscovery };","map":{"version":3,"names":["RegionDiscovery","constructor","networkInterface","logger","performanceClient","correlationId","detectRegion","environmentRegion","regionDiscoveryMetadata","_this$performanceClie","addQueueMeasurement","PerformanceEvents","RegionDiscoveryDetectRegion","autodetectedRegionName","options","IMDS_OPTIONS","localIMDSVersionResponse","invokeAsync","getRegionFromIMDS","bind","RegionDiscoveryGetRegionFromIMDS","Constants","IMDS_VERSION","status","HttpStatus","SUCCESS","body","region_source","RegionDiscoverySources","IMDS","BAD_REQUEST","currentIMDSVersion","getCurrentVersion","RegionDiscoveryGetCurrentVersion","FAILED_AUTO_DETECTION","currentIMDSVersionResponse","e","ENVIRONMENT_VARIABLE","version","_this$performanceClie2","sendGetRequestAsync","concat","IMDS_ENDPOINT","IMDS_TIMEOUT","_this$performanceClie3","response","length","headers","Metadata"],"sources":["/Users/tolu/pangram-cos-350/frontend/node_modules/@azure/msal-common/src/authority/RegionDiscovery.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule } from \"../network/INetworkModule.js\";\nimport { NetworkResponse } from \"../network/NetworkResponse.js\";\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse.js\";\nimport {\n    Constants,\n    HttpStatus,\n    RegionDiscoverySources,\n} from \"../utils/Constants.js\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata.js\";\nimport { ImdsOptions } from \"./ImdsOptions.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport { invokeAsync } from \"../utils/FunctionWrappers.js\";\nimport { Logger } from \"../logger/Logger.js\";\n\nexport class RegionDiscovery {\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Logger\n    private logger: Logger;\n    // Performance client\n    protected performanceClient: IPerformanceClient | undefined;\n    // CorrelationId\n    protected correlationId: string | undefined;\n    // Options for the IMDS endpoint request\n    protected static IMDS_OPTIONS: ImdsOptions = {\n        headers: {\n            Metadata: \"true\",\n        },\n    };\n\n    constructor(\n        networkInterface: INetworkModule,\n        logger: Logger,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ) {\n        this.networkInterface = networkInterface;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n        this.correlationId = correlationId;\n    }\n\n    /**\n     * Detect the region from the application's environment.\n     *\n     * @returns Promise<string | null>\n     */\n    public async detectRegion(\n        environmentRegion: string | undefined,\n        regionDiscoveryMetadata: RegionDiscoveryMetadata\n    ): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryDetectRegion,\n            this.correlationId\n        );\n\n        // Initialize auto detected region with the region from the envrionment\n        let autodetectedRegionName = environmentRegion;\n\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n        if (!autodetectedRegionName) {\n            const options = RegionDiscovery.IMDS_OPTIONS;\n\n            try {\n                const localIMDSVersionResponse = await invokeAsync(\n                    this.getRegionFromIMDS.bind(this),\n                    PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n                    this.logger,\n                    this.performanceClient,\n                    this.correlationId\n                )(Constants.IMDS_VERSION, options);\n                if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {\n                    autodetectedRegionName = localIMDSVersionResponse.body;\n                    regionDiscoveryMetadata.region_source =\n                        RegionDiscoverySources.IMDS;\n                }\n\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n                if (\n                    localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST\n                ) {\n                    const currentIMDSVersion = await invokeAsync(\n                        this.getCurrentVersion.bind(this),\n                        PerformanceEvents.RegionDiscoveryGetCurrentVersion,\n                        this.logger,\n                        this.performanceClient,\n                        this.correlationId\n                    )(options);\n                    if (!currentIMDSVersion) {\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                        return null;\n                    }\n\n                    const currentIMDSVersionResponse = await invokeAsync(\n                        this.getRegionFromIMDS.bind(this),\n                        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n                        this.logger,\n                        this.performanceClient,\n                        this.correlationId\n                    )(currentIMDSVersion, options);\n                    if (\n                        currentIMDSVersionResponse.status === HttpStatus.SUCCESS\n                    ) {\n                        autodetectedRegionName =\n                            currentIMDSVersionResponse.body;\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.IMDS;\n                    }\n                }\n            } catch (e) {\n                regionDiscoveryMetadata.region_source =\n                    RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                return null;\n            }\n        } else {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n        }\n\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n        if (!autodetectedRegionName) {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        }\n\n        return autodetectedRegionName || null;\n    }\n\n    /**\n     * Make the call to the IMDS endpoint\n     *\n     * @param imdsEndpointUrl\n     * @returns Promise<NetworkResponse<string>>\n     */\n    private async getRegionFromIMDS(\n        version: string,\n        options: ImdsOptions\n    ): Promise<NetworkResponse<string>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n            this.correlationId\n        );\n        return this.networkInterface.sendGetRequestAsync<string>(\n            `${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`,\n            options,\n            Constants.IMDS_TIMEOUT\n        );\n    }\n\n    /**\n     * Get the most recent version of the IMDS endpoint available\n     *\n     * @returns Promise<string | null>\n     */\n    private async getCurrentVersion(\n        options: ImdsOptions\n    ): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryGetCurrentVersion,\n            this.correlationId\n        );\n        try {\n            const response =\n                await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(\n                    `${Constants.IMDS_ENDPOINT}?format=json`,\n                    options\n                );\n\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (\n                response.status === HttpStatus.BAD_REQUEST &&\n                response.body &&\n                response.body[\"newest-versions\"] &&\n                response.body[\"newest-versions\"].length > 0\n            ) {\n                return response.body[\"newest-versions\"][0];\n            }\n\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}