{"ast":null,"code":"/*! @azure/msal-common v15.13.2 2025-11-19 */\n'use strict';\n\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from '../cache/entities/AccountEntity.mjs';\nimport { isInteractionRequiredError, InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.mjs';\nimport { Constants, HttpStatus, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { extractTokenClaims, checkMaxAge, isKmsi } from '../account/AuthToken.mjs';\nimport { getTenantIdFromIdTokenClaims } from '../account/TokenClaims.mjs';\nimport { updateAccountTenantProfileData, buildTenantProfile } from '../account/AccountInfo.mjs';\nimport { createIdTokenEntity, createAccessTokenEntity, createRefreshTokenEntity } from '../cache/utils/CacheHelpers.mjs';\nimport { toDateFromSeconds } from '../utils/TimeUtils.mjs';\nimport { nonceMismatch, authTimeNotFound, invalidCacheEnvironment, keyIdMissing } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Class that handles response parsing.\r\n * @internal\r\n */\nclass ResponseHandler {\n  constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   * @param refreshAccessToken\r\n   */\n  validateTokenResponse(serverResponse, refreshAccessToken) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      var _serverResponse$error;\n      const errString = \"Error(s): \".concat(serverResponse.error_codes || Constants.NOT_AVAILABLE, \" - Timestamp: \").concat(serverResponse.timestamp || Constants.NOT_AVAILABLE, \" - Description: \").concat(serverResponse.error_description || Constants.NOT_AVAILABLE, \" - Correlation ID: \").concat(serverResponse.correlation_id || Constants.NOT_AVAILABLE, \" - Trace ID: \").concat(serverResponse.trace_id || Constants.NOT_AVAILABLE);\n      const serverErrorNo = (_serverResponse$error = serverResponse.error_codes) !== null && _serverResponse$error !== void 0 && _serverResponse$error.length ? serverResponse.error_codes[0] : undefined;\n      const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);\n      // check if 500 error\n      if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {\n        this.logger.warning(\"executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n\".concat(serverError));\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n        // check if 400 error\n      } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {\n        this.logger.warning(\"executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n\".concat(serverError));\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n      }\n      if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);\n      }\n      throw serverError;\n    }\n  }\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n  async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _this$performanceClie;\n    (_this$performanceClie = this.performanceClient) === null || _this$performanceClie === void 0 || _this$performanceClie.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n    // create an idToken object (not entity)\n    let idTokenClaims;\n    if (serverTokenResponse.id_token) {\n      idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);\n      // token nonce check (TODO: Add a warning if no nonce is given?)\n      if (authCodePayload && authCodePayload.nonce) {\n        if (idTokenClaims.nonce !== authCodePayload.nonce) {\n          throw createClientAuthError(nonceMismatch);\n        }\n      }\n      // token max_age check\n      if (request.maxAge || request.maxAge === 0) {\n        const authTime = idTokenClaims.auth_time;\n        if (!authTime) {\n          throw createClientAuthError(authTimeNotFound);\n        }\n        checkMaxAge(authTime, request.maxAge);\n      }\n    }\n    // generate homeAccountId\n    this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\n    // save the response tokens\n    let requestStateObj;\n    if (!!authCodePayload && !!authCodePayload.state) {\n      requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n    }\n    // Add keyId from request to serverTokenResponse if defined\n    serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n    const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);\n    let cacheContext;\n    try {\n      if (this.persistencePlugin && this.serializableCache) {\n        this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n        cacheContext = new TokenCacheContext(this.serializableCache, true);\n        await this.persistencePlugin.beforeCacheAccess(cacheContext);\n      }\n      /*\r\n       * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n       * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n       * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n       * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n       */\n      if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n        const key = this.cacheStorage.generateAccountKey(AccountEntity.getAccountInfo(cacheRecord.account));\n        const account = this.cacheStorage.getAccount(key, request.correlationId);\n        if (!account) {\n          this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n          return await ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);\n        }\n      }\n      await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, isKmsi(idTokenClaims || {}), request.storeInCache);\n    } finally {\n      if (this.persistencePlugin && this.serializableCache && cacheContext) {\n        this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n        await this.persistencePlugin.afterCacheAccess(cacheContext);\n      }\n    }\n    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);\n  }\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n  generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {\n    const env = authority.getPreferredCache();\n    if (!env) {\n      throw createClientAuthError(invalidCacheEnvironment);\n    }\n    const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);\n    // IdToken: non AAD scenarios can have empty realm\n    let cachedIdToken;\n    let cachedAccount;\n    if (serverTokenResponse.id_token && !!idTokenClaims) {\n      cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || \"\");\n      cachedAccount = buildAccountToCache(this.cacheStorage, authority, this.homeAccountIdentifier, this.cryptoObj.base64Decode, request.correlationId, idTokenClaims, serverTokenResponse.client_info, env, claimsTenantId, authCodePayload, undefined,\n      // nativeAccountId\n      this.logger);\n    }\n    // AccessToken\n    let cachedAccessToken = null;\n    if (serverTokenResponse.access_token) {\n      // If scopes not returned in server response, use request scopes\n      const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n      const expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      const refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      const tokenExpirationSeconds = reqTimestamp + expiresIn;\n      const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || \"\", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    let cachedRefreshToken = null;\n    if (serverTokenResponse.refresh_token) {\n      let rtExpiresOn;\n      if (serverTokenResponse.refresh_token_expires_in) {\n        const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === \"string\" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;\n        rtExpiresOn = reqTimestamp + rtExpiresIn;\n      }\n      cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);\n    }\n    // appMetadata\n    let cachedAppMetadata = null;\n    if (serverTokenResponse.foci) {\n      cachedAppMetadata = {\n        clientId: this.clientId,\n        environment: env,\n        familyId: serverTokenResponse.foci\n      };\n    }\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  }\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n  static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {\n    var _cacheRecord$idToken, _cacheRecord$idToken2, _cacheRecord$accessTo, _cacheRecord$account, _cacheRecord$account2;\n    let accessToken = Constants.EMPTY_STRING;\n    let responseScopes = [];\n    let expiresOn = null;\n    let extExpiresOn;\n    let refreshOn;\n    let familyId = Constants.EMPTY_STRING;\n    if (cacheRecord.accessToken) {\n      /*\r\n       * if the request object has `popKid` property, `signPopToken` will be set to false and\r\n       * the token will be returned unsigned\r\n       */\n      if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {\n        const popTokenGenerator = new PopTokenGenerator(cryptoObj);\n        const {\n          secret,\n          keyId\n        } = cacheRecord.accessToken;\n        if (!keyId) {\n          throw createClientAuthError(keyIdMissing);\n        }\n        accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\n      } else {\n        accessToken = cacheRecord.accessToken.secret;\n      }\n      responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n      // Access token expiresOn cached in seconds, converting to Date for AuthenticationResult\n      expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);\n      extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);\n      if (cacheRecord.accessToken.refreshOn) {\n        refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);\n      }\n    }\n    if (cacheRecord.appMetadata) {\n      familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : \"\";\n    }\n    const uid = (idTokenClaims === null || idTokenClaims === void 0 ? void 0 : idTokenClaims.oid) || (idTokenClaims === null || idTokenClaims === void 0 ? void 0 : idTokenClaims.sub) || \"\";\n    const tid = (idTokenClaims === null || idTokenClaims === void 0 ? void 0 : idTokenClaims.tid) || \"\";\n    // for hybrid + native bridge enablement, send back the native account Id\n    if (serverTokenResponse !== null && serverTokenResponse !== void 0 && serverTokenResponse.spa_accountid && !!cacheRecord.account) {\n      cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\n    }\n    const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(AccountEntity.getAccountInfo(cacheRecord.account), undefined,\n    // tenantProfile optional\n    idTokenClaims, (_cacheRecord$idToken = cacheRecord.idToken) === null || _cacheRecord$idToken === void 0 ? void 0 : _cacheRecord$idToken.secret) : null;\n    return {\n      authority: authority.canonicalAuthority,\n      uniqueId: uid,\n      tenantId: tid,\n      scopes: responseScopes,\n      account: accountInfo,\n      idToken: (cacheRecord === null || cacheRecord === void 0 || (_cacheRecord$idToken2 = cacheRecord.idToken) === null || _cacheRecord$idToken2 === void 0 ? void 0 : _cacheRecord$idToken2.secret) || \"\",\n      idTokenClaims: idTokenClaims || {},\n      accessToken: accessToken,\n      fromCache: fromTokenCache,\n      expiresOn: expiresOn,\n      extExpiresOn: extExpiresOn,\n      refreshOn: refreshOn,\n      correlationId: request.correlationId,\n      requestId: requestId || Constants.EMPTY_STRING,\n      familyId: familyId,\n      tokenType: ((_cacheRecord$accessTo = cacheRecord.accessToken) === null || _cacheRecord$accessTo === void 0 ? void 0 : _cacheRecord$accessTo.tokenType) || Constants.EMPTY_STRING,\n      state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n      cloudGraphHostName: ((_cacheRecord$account = cacheRecord.account) === null || _cacheRecord$account === void 0 ? void 0 : _cacheRecord$account.cloudGraphHostName) || Constants.EMPTY_STRING,\n      msGraphHost: ((_cacheRecord$account2 = cacheRecord.account) === null || _cacheRecord$account2 === void 0 ? void 0 : _cacheRecord$account2.msGraphHost) || Constants.EMPTY_STRING,\n      code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\n      fromNativeBroker: false\n    };\n  }\n}\nfunction buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, correlationId, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {\n  logger === null || logger === void 0 || logger.verbose(\"setCachedAccount called\");\n  // Check if base account is already cached\n  const accountKeys = cacheStorage.getAccountKeys();\n  const baseAccountKey = accountKeys.find(accountKey => {\n    return accountKey.startsWith(homeAccountId);\n  });\n  let cachedAccount = null;\n  if (baseAccountKey) {\n    cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);\n  }\n  const baseAccount = cachedAccount || AccountEntity.createAccount({\n    homeAccountId,\n    idTokenClaims,\n    clientInfo,\n    environment,\n    cloudGraphHostName: authCodePayload === null || authCodePayload === void 0 ? void 0 : authCodePayload.cloud_graph_host_name,\n    msGraphHost: authCodePayload === null || authCodePayload === void 0 ? void 0 : authCodePayload.msgraph_host,\n    nativeAccountId: nativeAccountId\n  }, authority, base64Decode);\n  const tenantProfiles = baseAccount.tenantProfiles || [];\n  const tenantId = claimsTenantId || baseAccount.realm;\n  if (tenantId && !tenantProfiles.find(tenantProfile => {\n    return tenantProfile.tenantId === tenantId;\n  })) {\n    const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);\n    tenantProfiles.push(newTenantProfile);\n  }\n  baseAccount.tenantProfiles = tenantProfiles;\n  return baseAccount;\n}\nexport { ResponseHandler, buildAccountToCache };","map":{"version":3,"names":["ResponseHandler","constructor","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","validateTokenResponse","serverResponse","refreshAccessToken","error","error_description","suberror","_serverResponse$error","errString","concat","error_codes","Constants","NOT_AVAILABLE","timestamp","correlation_id","trace_id","serverErrorNo","length","undefined","serverError","ServerError","status","HttpStatus","SERVER_ERROR_RANGE_START","SERVER_ERROR_RANGE_END","warning","CLIENT_ERROR_RANGE_START","CLIENT_ERROR_RANGE_END","isInteractionRequiredError","InteractionRequiredAuthError","EMPTY_STRING","claims","handleServerTokenResponse","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","_this$performanceClie","addQueueMeasurement","PerformanceEvents","HandleServerTokenResponse","idTokenClaims","id_token","extractTokenClaims","base64Decode","nonce","createClientAuthError","nonceMismatch","maxAge","authTime","auth_time","authTimeNotFound","checkMaxAge","homeAccountIdentifier","AccountEntity","generateHomeAccountId","client_info","authorityType","requestStateObj","state","ProtocolUtils","parseRequestState","key_id","sshKid","cacheRecord","generateCacheRecord","cacheContext","verbose","TokenCacheContext","beforeCacheAccess","account","key","generateAccountKey","getAccountInfo","getAccount","correlationId","generateAuthenticationResult","saveCacheRecord","isKmsi","storeInCache","afterCacheAccess","env","getPreferredCache","invalidCacheEnvironment","claimsTenantId","getTenantIdFromIdTokenClaims","cachedIdToken","cachedAccount","createIdTokenEntity","buildAccountToCache","cachedAccessToken","access_token","responseScopes","scope","ScopeSet","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","rtExpiresOn","refresh_token_expires_in","rtExpiresIn","createRefreshTokenEntity","foci","cachedAppMetadata","environment","familyId","idToken","accessToken","refreshToken","appMetadata","fromTokenCache","requestState","requestId","_cacheRecord$idToken","_cacheRecord$idToken2","_cacheRecord$accessTo","_cacheRecord$account","_cacheRecord$account2","expiresOn","extExpiresOn","refreshOn","tokenType","AuthenticationScheme","POP","popKid","popTokenGenerator","PopTokenGenerator","secret","keyId","keyIdMissing","signPopToken","target","asArray","toDateFromSeconds","extendedExpiresOn","THE_FAMILY_ID","uid","oid","sub","tid","spa_accountid","nativeAccountId","accountInfo","updateAccountTenantProfileData","canonicalAuthority","uniqueId","tenantId","fromCache","userRequestState","cloudGraphHostName","msGraphHost","code","spa_code","fromNativeBroker","homeAccountId","clientInfo","accountKeys","getAccountKeys","baseAccountKey","find","accountKey","startsWith","baseAccount","createAccount","cloud_graph_host_name","msgraph_host","tenantProfiles","realm","tenantProfile","newTenantProfile","buildTenantProfile","localAccountId","push"],"sources":["/Users/tolu/pangram-cos-350/frontend/node_modules/@azure/msal-common/src/response/ResponseHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ServerAuthorizationTokenResponse } from \"./ServerAuthorizationTokenResponse.js\";\nimport { ICrypto } from \"../crypto/ICrypto.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError.js\";\nimport { Logger } from \"../logger/Logger.js\";\nimport { ServerError } from \"../error/ServerError.js\";\nimport { ScopeSet } from \"../request/ScopeSet.js\";\nimport { AuthenticationResult } from \"./AuthenticationResult.js\";\nimport { AccountEntity } from \"../cache/entities/AccountEntity.js\";\nimport { Authority } from \"../authority/Authority.js\";\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity.js\";\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity.js\";\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity.js\";\nimport {\n    InteractionRequiredAuthError,\n    isInteractionRequiredError,\n} from \"../error/InteractionRequiredAuthError.js\";\nimport { CacheRecord } from \"../cache/entities/CacheRecord.js\";\nimport { CacheManager } from \"../cache/CacheManager.js\";\nimport { ProtocolUtils, RequestStateObject } from \"../utils/ProtocolUtils.js\";\nimport {\n    AuthenticationScheme,\n    Constants,\n    THE_FAMILY_ID,\n    HttpStatus,\n} from \"../utils/Constants.js\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator.js\";\nimport { AppMetadataEntity } from \"../cache/entities/AppMetadataEntity.js\";\nimport { ICachePlugin } from \"../cache/interface/ICachePlugin.js\";\nimport { TokenCacheContext } from \"../cache/persistence/TokenCacheContext.js\";\nimport { ISerializableTokenCache } from \"../cache/interface/ISerializableTokenCache.js\";\nimport { AuthorizationCodePayload } from \"./AuthorizationCodePayload.js\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport {\n    checkMaxAge,\n    extractTokenClaims,\n    isKmsi,\n} from \"../account/AuthToken.js\";\nimport {\n    TokenClaims,\n    getTenantIdFromIdTokenClaims,\n} from \"../account/TokenClaims.js\";\nimport {\n    AccountInfo,\n    buildTenantProfile,\n    updateAccountTenantProfileData,\n} from \"../account/AccountInfo.js\";\nimport * as CacheHelpers from \"../cache/utils/CacheHelpers.js\";\nimport * as TimeUtils from \"../utils/TimeUtils.js\";\n\n/**\n * Class that handles response parsing.\n * @internal\n */\nexport class ResponseHandler {\n    private clientId: string;\n    private cacheStorage: CacheManager;\n    private cryptoObj: ICrypto;\n    private logger: Logger;\n    private homeAccountIdentifier: string;\n    private serializableCache: ISerializableTokenCache | null;\n    private persistencePlugin: ICachePlugin | null;\n    private performanceClient?: IPerformanceClient;\n\n    constructor(\n        clientId: string,\n        cacheStorage: CacheManager,\n        cryptoObj: ICrypto,\n        logger: Logger,\n        serializableCache: ISerializableTokenCache | null,\n        persistencePlugin: ICachePlugin | null,\n        performanceClient?: IPerformanceClient\n    ) {\n        this.clientId = clientId;\n        this.cacheStorage = cacheStorage;\n        this.cryptoObj = cryptoObj;\n        this.logger = logger;\n        this.serializableCache = serializableCache;\n        this.persistencePlugin = persistencePlugin;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Function which validates server authorization token response.\n     * @param serverResponse\n     * @param refreshAccessToken\n     */\n    validateTokenResponse(\n        serverResponse: ServerAuthorizationTokenResponse,\n        refreshAccessToken?: boolean\n    ): void {\n        // Check for error\n        if (\n            serverResponse.error ||\n            serverResponse.error_description ||\n            serverResponse.suberror\n        ) {\n            const errString = `Error(s): ${\n                serverResponse.error_codes || Constants.NOT_AVAILABLE\n            } - Timestamp: ${\n                serverResponse.timestamp || Constants.NOT_AVAILABLE\n            } - Description: ${\n                serverResponse.error_description || Constants.NOT_AVAILABLE\n            } - Correlation ID: ${\n                serverResponse.correlation_id || Constants.NOT_AVAILABLE\n            } - Trace ID: ${\n                serverResponse.trace_id || Constants.NOT_AVAILABLE\n            }`;\n            const serverErrorNo = serverResponse.error_codes?.length\n                ? serverResponse.error_codes[0]\n                : undefined;\n            const serverError = new ServerError(\n                serverResponse.error,\n                errString,\n                serverResponse.suberror,\n                serverErrorNo,\n                serverResponse.status\n            );\n\n            // check if 500 error\n            if (\n                refreshAccessToken &&\n                serverResponse.status &&\n                serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&\n                serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END\n            ) {\n                this.logger.warning(\n                    `executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`\n                );\n\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n                return;\n                // check if 400 error\n            } else if (\n                refreshAccessToken &&\n                serverResponse.status &&\n                serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&\n                serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END\n            ) {\n                this.logger.warning(\n                    `executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`\n                );\n\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n                return;\n            }\n\n            if (\n                isInteractionRequiredError(\n                    serverResponse.error,\n                    serverResponse.error_description,\n                    serverResponse.suberror\n                )\n            ) {\n                throw new InteractionRequiredAuthError(\n                    serverResponse.error,\n                    serverResponse.error_description,\n                    serverResponse.suberror,\n                    serverResponse.timestamp || Constants.EMPTY_STRING,\n                    serverResponse.trace_id || Constants.EMPTY_STRING,\n                    serverResponse.correlation_id || Constants.EMPTY_STRING,\n                    serverResponse.claims || Constants.EMPTY_STRING,\n                    serverErrorNo\n                );\n            }\n\n            throw serverError;\n        }\n    }\n\n    /**\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\n     * @param serverTokenResponse\n     * @param authority\n     */\n    async handleServerTokenResponse(\n        serverTokenResponse: ServerAuthorizationTokenResponse,\n        authority: Authority,\n        reqTimestamp: number,\n        request: BaseAuthRequest,\n        authCodePayload?: AuthorizationCodePayload,\n        userAssertionHash?: string,\n        handlingRefreshTokenResponse?: boolean,\n        forceCacheRefreshTokenResponse?: boolean,\n        serverRequestId?: string\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.HandleServerTokenResponse,\n            serverTokenResponse.correlation_id\n        );\n\n        // create an idToken object (not entity)\n        let idTokenClaims: TokenClaims | undefined;\n        if (serverTokenResponse.id_token) {\n            idTokenClaims = extractTokenClaims(\n                serverTokenResponse.id_token || Constants.EMPTY_STRING,\n                this.cryptoObj.base64Decode\n            );\n\n            // token nonce check (TODO: Add a warning if no nonce is given?)\n            if (authCodePayload && authCodePayload.nonce) {\n                if (idTokenClaims.nonce !== authCodePayload.nonce) {\n                    throw createClientAuthError(\n                        ClientAuthErrorCodes.nonceMismatch\n                    );\n                }\n            }\n\n            // token max_age check\n            if (request.maxAge || request.maxAge === 0) {\n                const authTime = idTokenClaims.auth_time;\n                if (!authTime) {\n                    throw createClientAuthError(\n                        ClientAuthErrorCodes.authTimeNotFound\n                    );\n                }\n\n                checkMaxAge(authTime, request.maxAge);\n            }\n        }\n\n        // generate homeAccountId\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(\n            serverTokenResponse.client_info || Constants.EMPTY_STRING,\n            authority.authorityType,\n            this.logger,\n            this.cryptoObj,\n            idTokenClaims\n        );\n\n        // save the response tokens\n        let requestStateObj: RequestStateObject | undefined;\n        if (!!authCodePayload && !!authCodePayload.state) {\n            requestStateObj = ProtocolUtils.parseRequestState(\n                this.cryptoObj,\n                authCodePayload.state\n            );\n        }\n\n        // Add keyId from request to serverTokenResponse if defined\n        serverTokenResponse.key_id =\n            serverTokenResponse.key_id || request.sshKid || undefined;\n\n        const cacheRecord = this.generateCacheRecord(\n            serverTokenResponse,\n            authority,\n            reqTimestamp,\n            request,\n            idTokenClaims,\n            userAssertionHash,\n            authCodePayload\n        );\n        let cacheContext;\n        try {\n            if (this.persistencePlugin && this.serializableCache) {\n                this.logger.verbose(\n                    \"Persistence enabled, calling beforeCacheAccess\"\n                );\n                cacheContext = new TokenCacheContext(\n                    this.serializableCache,\n                    true\n                );\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\n            }\n            /*\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\n             */\n            if (\n                handlingRefreshTokenResponse &&\n                !forceCacheRefreshTokenResponse &&\n                cacheRecord.account\n            ) {\n                const key = this.cacheStorage.generateAccountKey(\n                    AccountEntity.getAccountInfo(cacheRecord.account)\n                );\n                const account = this.cacheStorage.getAccount(\n                    key,\n                    request.correlationId\n                );\n                if (!account) {\n                    this.logger.warning(\n                        \"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\"\n                    );\n                    return await ResponseHandler.generateAuthenticationResult(\n                        this.cryptoObj,\n                        authority,\n                        cacheRecord,\n                        false,\n                        request,\n                        idTokenClaims,\n                        requestStateObj,\n                        undefined,\n                        serverRequestId\n                    );\n                }\n            }\n            await this.cacheStorage.saveCacheRecord(\n                cacheRecord,\n                request.correlationId,\n                isKmsi(idTokenClaims || {}),\n                request.storeInCache\n            );\n        } finally {\n            if (\n                this.persistencePlugin &&\n                this.serializableCache &&\n                cacheContext\n            ) {\n                this.logger.verbose(\n                    \"Persistence enabled, calling afterCacheAccess\"\n                );\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\n            }\n        }\n\n        return ResponseHandler.generateAuthenticationResult(\n            this.cryptoObj,\n            authority,\n            cacheRecord,\n            false,\n            request,\n            idTokenClaims,\n            requestStateObj,\n            serverTokenResponse,\n            serverRequestId\n        );\n    }\n\n    /**\n     * Generates CacheRecord\n     * @param serverTokenResponse\n     * @param idTokenObj\n     * @param authority\n     */\n    private generateCacheRecord(\n        serverTokenResponse: ServerAuthorizationTokenResponse,\n        authority: Authority,\n        reqTimestamp: number,\n        request: BaseAuthRequest,\n        idTokenClaims?: TokenClaims,\n        userAssertionHash?: string,\n        authCodePayload?: AuthorizationCodePayload\n    ): CacheRecord {\n        const env = authority.getPreferredCache();\n        if (!env) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.invalidCacheEnvironment\n            );\n        }\n\n        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);\n\n        // IdToken: non AAD scenarios can have empty realm\n        let cachedIdToken: IdTokenEntity | undefined;\n        let cachedAccount: AccountEntity | undefined;\n        if (serverTokenResponse.id_token && !!idTokenClaims) {\n            cachedIdToken = CacheHelpers.createIdTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.id_token,\n                this.clientId,\n                claimsTenantId || \"\"\n            );\n\n            cachedAccount = buildAccountToCache(\n                this.cacheStorage,\n                authority,\n                this.homeAccountIdentifier,\n                this.cryptoObj.base64Decode,\n                request.correlationId,\n                idTokenClaims,\n                serverTokenResponse.client_info,\n                env,\n                claimsTenantId,\n                authCodePayload,\n                undefined, // nativeAccountId\n                this.logger\n            );\n        }\n\n        // AccessToken\n        let cachedAccessToken: AccessTokenEntity | null = null;\n        if (serverTokenResponse.access_token) {\n            // If scopes not returned in server response, use request scopes\n            const responseScopes = serverTokenResponse.scope\n                ? ScopeSet.fromString(serverTokenResponse.scope)\n                : new ScopeSet(request.scopes || []);\n\n            /*\n             * Use timestamp calculated before request\n             * Server may return timestamps as strings, parse to numbers if so.\n             */\n            const expiresIn: number =\n                (typeof serverTokenResponse.expires_in === \"string\"\n                    ? parseInt(serverTokenResponse.expires_in, 10)\n                    : serverTokenResponse.expires_in) || 0;\n            const extExpiresIn: number =\n                (typeof serverTokenResponse.ext_expires_in === \"string\"\n                    ? parseInt(serverTokenResponse.ext_expires_in, 10)\n                    : serverTokenResponse.ext_expires_in) || 0;\n            const refreshIn: number | undefined =\n                (typeof serverTokenResponse.refresh_in === \"string\"\n                    ? parseInt(serverTokenResponse.refresh_in, 10)\n                    : serverTokenResponse.refresh_in) || undefined;\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\n            const extendedTokenExpirationSeconds =\n                tokenExpirationSeconds + extExpiresIn;\n            const refreshOnSeconds =\n                refreshIn && refreshIn > 0\n                    ? reqTimestamp + refreshIn\n                    : undefined;\n\n            // non AAD scenarios can have empty realm\n            cachedAccessToken = CacheHelpers.createAccessTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.access_token,\n                this.clientId,\n                claimsTenantId || authority.tenant || \"\",\n                responseScopes.printScopes(),\n                tokenExpirationSeconds,\n                extendedTokenExpirationSeconds,\n                this.cryptoObj.base64Decode,\n                refreshOnSeconds,\n                serverTokenResponse.token_type,\n                userAssertionHash,\n                serverTokenResponse.key_id,\n                request.claims,\n                request.requestedClaimsHash\n            );\n        }\n\n        // refreshToken\n        let cachedRefreshToken: RefreshTokenEntity | null = null;\n        if (serverTokenResponse.refresh_token) {\n            let rtExpiresOn: number | undefined;\n            if (serverTokenResponse.refresh_token_expires_in) {\n                const rtExpiresIn: number =\n                    typeof serverTokenResponse.refresh_token_expires_in ===\n                    \"string\"\n                        ? parseInt(\n                              serverTokenResponse.refresh_token_expires_in,\n                              10\n                          )\n                        : serverTokenResponse.refresh_token_expires_in;\n                rtExpiresOn = reqTimestamp + rtExpiresIn;\n            }\n            cachedRefreshToken = CacheHelpers.createRefreshTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.refresh_token,\n                this.clientId,\n                serverTokenResponse.foci,\n                userAssertionHash,\n                rtExpiresOn\n            );\n        }\n\n        // appMetadata\n        let cachedAppMetadata: AppMetadataEntity | null = null;\n        if (serverTokenResponse.foci) {\n            cachedAppMetadata = {\n                clientId: this.clientId,\n                environment: env,\n                familyId: serverTokenResponse.foci,\n            };\n        }\n\n        return {\n            account: cachedAccount,\n            idToken: cachedIdToken,\n            accessToken: cachedAccessToken,\n            refreshToken: cachedRefreshToken,\n            appMetadata: cachedAppMetadata,\n        };\n    }\n\n    /**\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\n     *\n     * Optionally takes a state string that is set as-is in the response.\n     *\n     * @param cacheRecord\n     * @param idTokenObj\n     * @param fromTokenCache\n     * @param stateString\n     */\n    static async generateAuthenticationResult(\n        cryptoObj: ICrypto,\n        authority: Authority,\n        cacheRecord: CacheRecord,\n        fromTokenCache: boolean,\n        request: BaseAuthRequest,\n        idTokenClaims?: TokenClaims,\n        requestState?: RequestStateObject,\n        serverTokenResponse?: ServerAuthorizationTokenResponse,\n        requestId?: string\n    ): Promise<AuthenticationResult> {\n        let accessToken: string = Constants.EMPTY_STRING;\n        let responseScopes: Array<string> = [];\n        let expiresOn: Date | null = null;\n        let extExpiresOn: Date | undefined;\n        let refreshOn: Date | undefined;\n        let familyId: string = Constants.EMPTY_STRING;\n\n        if (cacheRecord.accessToken) {\n            /*\n             * if the request object has `popKid` property, `signPopToken` will be set to false and\n             * the token will be returned unsigned\n             */\n            if (\n                cacheRecord.accessToken.tokenType ===\n                    AuthenticationScheme.POP &&\n                !request.popKid\n            ) {\n                const popTokenGenerator: PopTokenGenerator =\n                    new PopTokenGenerator(cryptoObj);\n                const { secret, keyId } = cacheRecord.accessToken;\n\n                if (!keyId) {\n                    throw createClientAuthError(\n                        ClientAuthErrorCodes.keyIdMissing\n                    );\n                }\n\n                accessToken = await popTokenGenerator.signPopToken(\n                    secret,\n                    keyId,\n                    request\n                );\n            } else {\n                accessToken = cacheRecord.accessToken.secret;\n            }\n            responseScopes = ScopeSet.fromString(\n                cacheRecord.accessToken.target\n            ).asArray();\n            // Access token expiresOn cached in seconds, converting to Date for AuthenticationResult\n            expiresOn = TimeUtils.toDateFromSeconds(\n                cacheRecord.accessToken.expiresOn\n            );\n            extExpiresOn = TimeUtils.toDateFromSeconds(\n                cacheRecord.accessToken.extendedExpiresOn\n            );\n            if (cacheRecord.accessToken.refreshOn) {\n                refreshOn = TimeUtils.toDateFromSeconds(\n                    cacheRecord.accessToken.refreshOn\n                );\n            }\n        }\n\n        if (cacheRecord.appMetadata) {\n            familyId =\n                cacheRecord.appMetadata.familyId === THE_FAMILY_ID\n                    ? THE_FAMILY_ID\n                    : \"\";\n        }\n        const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\n        const tid = idTokenClaims?.tid || \"\";\n\n        // for hybrid + native bridge enablement, send back the native account Id\n        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\n            cacheRecord.account.nativeAccountId =\n                serverTokenResponse?.spa_accountid;\n        }\n\n        const accountInfo: AccountInfo | null = cacheRecord.account\n            ? updateAccountTenantProfileData(\n                  AccountEntity.getAccountInfo(cacheRecord.account),\n                  undefined, // tenantProfile optional\n                  idTokenClaims,\n                  cacheRecord.idToken?.secret\n              )\n            : null;\n\n        return {\n            authority: authority.canonicalAuthority,\n            uniqueId: uid,\n            tenantId: tid,\n            scopes: responseScopes,\n            account: accountInfo,\n            idToken: cacheRecord?.idToken?.secret || \"\",\n            idTokenClaims: idTokenClaims || {},\n            accessToken: accessToken,\n            fromCache: fromTokenCache,\n            expiresOn: expiresOn,\n            extExpiresOn: extExpiresOn,\n            refreshOn: refreshOn,\n            correlationId: request.correlationId,\n            requestId: requestId || Constants.EMPTY_STRING,\n            familyId: familyId,\n            tokenType:\n                cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n            state: requestState\n                ? requestState.userRequestState\n                : Constants.EMPTY_STRING,\n            cloudGraphHostName:\n                cacheRecord.account?.cloudGraphHostName ||\n                Constants.EMPTY_STRING,\n            msGraphHost:\n                cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n            code: serverTokenResponse?.spa_code,\n            fromNativeBroker: false,\n        };\n    }\n}\n\nexport function buildAccountToCache(\n    cacheStorage: CacheManager,\n    authority: Authority,\n    homeAccountId: string,\n    base64Decode: (input: string) => string,\n    correlationId: string,\n    idTokenClaims?: TokenClaims,\n    clientInfo?: string,\n    environment?: string,\n    claimsTenantId?: string | null,\n    authCodePayload?: AuthorizationCodePayload,\n    nativeAccountId?: string,\n    logger?: Logger\n): AccountEntity {\n    logger?.verbose(\"setCachedAccount called\");\n\n    // Check if base account is already cached\n    const accountKeys = cacheStorage.getAccountKeys();\n    const baseAccountKey = accountKeys.find((accountKey: string) => {\n        return accountKey.startsWith(homeAccountId);\n    });\n\n    let cachedAccount: AccountEntity | null = null;\n    if (baseAccountKey) {\n        cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);\n    }\n\n    const baseAccount =\n        cachedAccount ||\n        AccountEntity.createAccount(\n            {\n                homeAccountId,\n                idTokenClaims,\n                clientInfo,\n                environment,\n                cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\n                msGraphHost: authCodePayload?.msgraph_host,\n                nativeAccountId: nativeAccountId,\n            },\n            authority,\n            base64Decode\n        );\n\n    const tenantProfiles = baseAccount.tenantProfiles || [];\n    const tenantId = claimsTenantId || baseAccount.realm;\n    if (\n        tenantId &&\n        !tenantProfiles.find((tenantProfile) => {\n            return tenantProfile.tenantId === tenantId;\n        })\n    ) {\n        const newTenantProfile = buildTenantProfile(\n            homeAccountId,\n            baseAccount.localAccountId,\n            tenantId,\n            idTokenClaims\n        );\n        tenantProfiles.push(newTenantProfile);\n    }\n    baseAccount.tenantProfiles = tenantProfiles;\n\n    return baseAccount;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}