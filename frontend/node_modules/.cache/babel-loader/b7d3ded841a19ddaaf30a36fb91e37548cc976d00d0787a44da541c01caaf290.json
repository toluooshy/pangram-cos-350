{"ast":null,"code":"/*! @azure/msal-browser v4.26.2 2025-11-19 */\n'use strict';\n\nimport _objectSpread from \"/Users/tolu/pangram-cos-350/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { invoke, PerformanceEvents, invokeAsync } from '@azure/msal-common/browser';\nimport { generateHKDF, createNewGuid, generateBaseKey, decrypt, encrypt } from '../crypto/BrowserCrypto.mjs';\nimport { base64DecToArr } from '../encode/Base64Decode.mjs';\nimport { urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { createBrowserConfigurationAuthError } from '../error/BrowserConfigurationAuthError.mjs';\nimport { CookieStorage, SameSiteOptions } from './CookieStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { getAccountKeys, getTokenKeys } from './CacheHelpers.mjs';\nimport { PREFIX, getAccountKeysCacheKey, getTokenKeysCacheKey } from './CacheKeys.mjs';\nimport { isEncrypted } from './EncryptedData.mjs';\nimport { storageNotSupported } from '../error/BrowserConfigurationAuthErrorCodes.mjs';\nimport { uninitializedPublicClientApplication } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst ENCRYPTION_KEY = \"msal.cache.encryption\";\nconst BROADCAST_CHANNEL_NAME = \"msal.broadcast.cache\";\nclass LocalStorage {\n  constructor(clientId, logger, performanceClient) {\n    if (!window.localStorage) {\n      throw createBrowserConfigurationAuthError(storageNotSupported);\n    }\n    this.memoryStorage = new MemoryStorage();\n    this.initialized = false;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n  }\n  async initialize(correlationId) {\n    const cookies = new CookieStorage();\n    const cookieString = cookies.getItem(ENCRYPTION_KEY);\n    let parsedCookie = {\n      key: \"\",\n      id: \"\"\n    };\n    if (cookieString) {\n      try {\n        parsedCookie = JSON.parse(cookieString);\n      } catch (e) {}\n    }\n    if (parsedCookie.key && parsedCookie.id) {\n      // Encryption key already exists, import\n      const baseKey = invoke(base64DecToArr, PerformanceEvents.Base64Decode, this.logger, this.performanceClient, correlationId)(parsedCookie.key);\n      this.encryptionCookie = {\n        id: parsedCookie.id,\n        key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)\n      };\n    } else {\n      // Encryption key doesn't exist or is invalid, generate a new one\n      const id = createNewGuid();\n      const baseKey = await invokeAsync(generateBaseKey, PerformanceEvents.GenerateBaseKey, this.logger, this.performanceClient, correlationId)();\n      const keyStr = invoke(urlEncodeArr, PerformanceEvents.UrlEncodeArr, this.logger, this.performanceClient, correlationId)(new Uint8Array(baseKey));\n      this.encryptionCookie = {\n        id: id,\n        key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)\n      };\n      const cookieData = {\n        id: id,\n        key: keyStr\n      };\n      cookies.setItem(ENCRYPTION_KEY, JSON.stringify(cookieData), 0,\n      // Expiration - 0 means cookie will be cleared at the end of the browser session\n      true,\n      // Secure flag\n      SameSiteOptions.None // SameSite must be None to support iframed apps\n      );\n    }\n    await invokeAsync(this.importExistingCache.bind(this), PerformanceEvents.ImportExistingCache, this.logger, this.performanceClient, correlationId)(correlationId);\n    // Register listener for cache updates in other tabs\n    this.broadcast.addEventListener(\"message\", this.updateCache.bind(this));\n    this.initialized = true;\n  }\n  getItem(key) {\n    return window.localStorage.getItem(key);\n  }\n  getUserData(key) {\n    if (!this.initialized) {\n      throw createBrowserAuthError(uninitializedPublicClientApplication);\n    }\n    return this.memoryStorage.getItem(key);\n  }\n  async decryptData(key, data, correlationId) {\n    if (!this.initialized || !this.encryptionCookie) {\n      throw createBrowserAuthError(uninitializedPublicClientApplication);\n    }\n    if (data.id !== this.encryptionCookie.id) {\n      // Data was encrypted with a different key. It must be removed because it is from a previous session.\n      this.performanceClient.incrementFields({\n        encryptedCacheExpiredCount: 1\n      }, correlationId);\n      return null;\n    }\n    const decryptedData = await invokeAsync(decrypt, PerformanceEvents.Decrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, data.nonce, this.getContext(key), data.data);\n    if (!decryptedData) {\n      return null;\n    }\n    try {\n      return _objectSpread(_objectSpread({}, JSON.parse(decryptedData)), {}, {\n        lastUpdatedAt: data.lastUpdatedAt\n      });\n    } catch (e) {\n      this.performanceClient.incrementFields({\n        encryptedCacheCorruptionCount: 1\n      }, correlationId);\n      return null;\n    }\n  }\n  setItem(key, value) {\n    window.localStorage.setItem(key, value);\n  }\n  async setUserData(key, value, correlationId, timestamp, kmsi) {\n    if (!this.initialized || !this.encryptionCookie) {\n      throw createBrowserAuthError(uninitializedPublicClientApplication);\n    }\n    if (kmsi) {\n      this.setItem(key, value);\n    } else {\n      const {\n        data,\n        nonce\n      } = await invokeAsync(encrypt, PerformanceEvents.Encrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, value, this.getContext(key));\n      const encryptedData = {\n        id: this.encryptionCookie.id,\n        nonce: nonce,\n        data: data,\n        lastUpdatedAt: timestamp\n      };\n      this.setItem(key, JSON.stringify(encryptedData));\n    }\n    this.memoryStorage.setItem(key, value);\n    // Notify other frames to update their in-memory cache\n    this.broadcast.postMessage({\n      key: key,\n      value: value,\n      context: this.getContext(key)\n    });\n  }\n  removeItem(key) {\n    if (this.memoryStorage.containsKey(key)) {\n      this.memoryStorage.removeItem(key);\n      this.broadcast.postMessage({\n        key: key,\n        value: null,\n        context: this.getContext(key)\n      });\n    }\n    window.localStorage.removeItem(key);\n  }\n  getKeys() {\n    return Object.keys(window.localStorage);\n  }\n  containsKey(key) {\n    return window.localStorage.hasOwnProperty(key);\n  }\n  /**\r\n   * Removes all known MSAL keys from the cache\r\n   */\n  clear() {\n    // Removes all remaining MSAL cache items\n    this.memoryStorage.clear();\n    const accountKeys = getAccountKeys(this);\n    accountKeys.forEach(key => this.removeItem(key));\n    const tokenKeys = getTokenKeys(this.clientId, this);\n    tokenKeys.idToken.forEach(key => this.removeItem(key));\n    tokenKeys.accessToken.forEach(key => this.removeItem(key));\n    tokenKeys.refreshToken.forEach(key => this.removeItem(key));\n    // Clean up anything left\n    this.getKeys().forEach(cacheKey => {\n      if (cacheKey.startsWith(PREFIX) || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeItem(cacheKey);\n      }\n    });\n  }\n  /**\r\n   * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage\r\n   * @returns\r\n   */\n  async importExistingCache(correlationId) {\n    if (!this.encryptionCookie) {\n      return;\n    }\n    let accountKeys = getAccountKeys(this);\n    accountKeys = await this.importArray(accountKeys, correlationId);\n    // Write valid account keys back to map\n    if (accountKeys.length) {\n      this.setItem(getAccountKeysCacheKey(), JSON.stringify(accountKeys));\n    } else {\n      this.removeItem(getAccountKeysCacheKey());\n    }\n    const tokenKeys = getTokenKeys(this.clientId, this);\n    tokenKeys.idToken = await this.importArray(tokenKeys.idToken, correlationId);\n    tokenKeys.accessToken = await this.importArray(tokenKeys.accessToken, correlationId);\n    tokenKeys.refreshToken = await this.importArray(tokenKeys.refreshToken, correlationId);\n    // Write valid token keys back to map\n    if (tokenKeys.idToken.length || tokenKeys.accessToken.length || tokenKeys.refreshToken.length) {\n      this.setItem(getTokenKeysCacheKey(this.clientId), JSON.stringify(tokenKeys));\n    } else {\n      this.removeItem(getTokenKeysCacheKey(this.clientId));\n    }\n  }\n  /**\r\n   * Helper to decrypt and save cache entries\r\n   * @param key\r\n   * @returns\r\n   */\n  async getItemFromEncryptedCache(key, correlationId) {\n    if (!this.encryptionCookie) {\n      return null;\n    }\n    const rawCache = this.getItem(key);\n    if (!rawCache) {\n      return null;\n    }\n    let encObj;\n    try {\n      encObj = JSON.parse(rawCache);\n    } catch (e) {\n      // Not a valid encrypted object, remove\n      return null;\n    }\n    if (!isEncrypted(encObj)) {\n      // Data is not encrypted\n      this.performanceClient.incrementFields({\n        unencryptedCacheCount: 1\n      }, correlationId);\n      return rawCache;\n    }\n    if (encObj.id !== this.encryptionCookie.id) {\n      // Data was encrypted with a different key. It must be removed because it is from a previous session.\n      this.performanceClient.incrementFields({\n        encryptedCacheExpiredCount: 1\n      }, correlationId);\n      return null;\n    }\n    this.performanceClient.incrementFields({\n      encryptedCacheCount: 1\n    }, correlationId);\n    return invokeAsync(decrypt, PerformanceEvents.Decrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, encObj.nonce, this.getContext(key), encObj.data);\n  }\n  /**\r\n   * Helper to decrypt and save an array of cache keys\r\n   * @param arr\r\n   * @returns Array of keys successfully imported\r\n   */\n  async importArray(arr, correlationId) {\n    const importedArr = [];\n    const promiseArr = [];\n    arr.forEach(key => {\n      const promise = this.getItemFromEncryptedCache(key, correlationId).then(value => {\n        if (value) {\n          this.memoryStorage.setItem(key, value);\n          importedArr.push(key);\n        } else {\n          // If value is empty, unencrypted or expired remove\n          this.removeItem(key);\n        }\n      });\n      promiseArr.push(promise);\n    });\n    await Promise.all(promiseArr);\n    return importedArr;\n  }\n  /**\r\n   * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries\r\n   * @param key\r\n   * @returns\r\n   */\n  getContext(key) {\n    let context = \"\";\n    if (key.includes(this.clientId)) {\n      context = this.clientId; // Used to bind encryption key to this appId\n    }\n    return context;\n  }\n  updateCache(event) {\n    this.logger.trace(\"Updating internal cache from broadcast event\");\n    const perfMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.LocalStorageUpdated);\n    perfMeasurement.add({\n      isBackground: true\n    });\n    const {\n      key,\n      value,\n      context\n    } = event.data;\n    if (!key) {\n      this.logger.error(\"Broadcast event missing key\");\n      perfMeasurement.end({\n        success: false,\n        errorCode: \"noKey\"\n      });\n      return;\n    }\n    if (context && context !== this.clientId) {\n      this.logger.trace(\"Ignoring broadcast event from clientId: \".concat(context));\n      perfMeasurement.end({\n        success: false,\n        errorCode: \"contextMismatch\"\n      });\n      return;\n    }\n    if (!value) {\n      this.memoryStorage.removeItem(key);\n      this.logger.verbose(\"Removed item from internal cache\");\n    } else {\n      this.memoryStorage.setItem(key, value);\n      this.logger.verbose(\"Updated item in internal cache\");\n    }\n    perfMeasurement.end({\n      success: true\n    });\n  }\n}\nexport { LocalStorage };","map":{"version":3,"names":["ENCRYPTION_KEY","BROADCAST_CHANNEL_NAME","LocalStorage","constructor","clientId","logger","performanceClient","window","localStorage","createBrowserConfigurationAuthError","storageNotSupported","memoryStorage","MemoryStorage","initialized","broadcast","BroadcastChannel","initialize","correlationId","cookies","CookieStorage","cookieString","getItem","parsedCookie","key","id","JSON","parse","e","baseKey","invoke","base64DecToArr","PerformanceEvents","Base64Decode","encryptionCookie","invokeAsync","generateHKDF","GenerateHKDF","createNewGuid","generateBaseKey","GenerateBaseKey","keyStr","urlEncodeArr","UrlEncodeArr","Uint8Array","cookieData","setItem","stringify","SameSiteOptions","None","importExistingCache","bind","ImportExistingCache","addEventListener","updateCache","getUserData","createBrowserAuthError","uninitializedPublicClientApplication","decryptData","data","incrementFields","encryptedCacheExpiredCount","decryptedData","decrypt","Decrypt","nonce","getContext","_objectSpread","lastUpdatedAt","encryptedCacheCorruptionCount","value","setUserData","timestamp","kmsi","encrypt","Encrypt","encryptedData","postMessage","context","removeItem","containsKey","getKeys","Object","keys","hasOwnProperty","clear","accountKeys","getAccountKeys","forEach","tokenKeys","getTokenKeys","idToken","accessToken","refreshToken","cacheKey","startsWith","PREFIX","indexOf","importArray","length","getAccountKeysCacheKey","getTokenKeysCacheKey","getItemFromEncryptedCache","rawCache","encObj","isEncrypted","unencryptedCacheCount","encryptedCacheCount","arr","importedArr","promiseArr","promise","then","push","Promise","all","includes","event","trace","perfMeasurement","startMeasurement","LocalStorageUpdated","add","isBackground","error","end","success","errorCode","concat","verbose"],"sources":["/Users/tolu/pangram-cos-350/frontend/node_modules/@azure/msal-browser/src/cache/LocalStorage.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    TokenKeys,\n    IPerformanceClient,\n    invokeAsync,\n    PerformanceEvents,\n    Logger,\n    invoke,\n} from \"@azure/msal-common/browser\";\nimport {\n    createNewGuid,\n    decrypt,\n    encrypt,\n    generateBaseKey,\n    generateHKDF,\n} from \"../crypto/BrowserCrypto.js\";\nimport { base64DecToArr } from \"../encode/Base64Decode.js\";\nimport { urlEncodeArr } from \"../encode/Base64Encode.js\";\nimport {\n    BrowserAuthErrorCodes,\n    createBrowserAuthError,\n} from \"../error/BrowserAuthError.js\";\nimport {\n    BrowserConfigurationAuthErrorCodes,\n    createBrowserConfigurationAuthError,\n} from \"../error/BrowserConfigurationAuthError.js\";\nimport { CookieStorage, SameSiteOptions } from \"./CookieStorage.js\";\nimport { IWindowStorage } from \"./IWindowStorage.js\";\nimport { MemoryStorage } from \"./MemoryStorage.js\";\nimport { getAccountKeys, getTokenKeys } from \"./CacheHelpers.js\";\nimport * as CacheKeys from \"./CacheKeys.js\";\nimport { EncryptedData, isEncrypted } from \"./EncryptedData.js\";\n\nconst ENCRYPTION_KEY = \"msal.cache.encryption\";\nconst BROADCAST_CHANNEL_NAME = \"msal.broadcast.cache\";\n\ntype EncryptionCookie = {\n    id: string;\n    key: CryptoKey;\n};\n\nexport class LocalStorage implements IWindowStorage<string> {\n    private clientId: string;\n    private initialized: boolean;\n    private memoryStorage: MemoryStorage<string>;\n    private performanceClient: IPerformanceClient;\n    private logger: Logger;\n    private encryptionCookie?: EncryptionCookie;\n    private broadcast: BroadcastChannel;\n\n    constructor(\n        clientId: string,\n        logger: Logger,\n        performanceClient: IPerformanceClient\n    ) {\n        if (!window.localStorage) {\n            throw createBrowserConfigurationAuthError(\n                BrowserConfigurationAuthErrorCodes.storageNotSupported\n            );\n        }\n        this.memoryStorage = new MemoryStorage<string>();\n        this.initialized = false;\n        this.clientId = clientId;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n        this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n    }\n\n    async initialize(correlationId: string): Promise<void> {\n        const cookies = new CookieStorage();\n        const cookieString = cookies.getItem(ENCRYPTION_KEY);\n        let parsedCookie = { key: \"\", id: \"\" };\n        if (cookieString) {\n            try {\n                parsedCookie = JSON.parse(cookieString);\n            } catch (e) {}\n        }\n        if (parsedCookie.key && parsedCookie.id) {\n            // Encryption key already exists, import\n            const baseKey = invoke(\n                base64DecToArr,\n                PerformanceEvents.Base64Decode,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )(parsedCookie.key);\n            this.encryptionCookie = {\n                id: parsedCookie.id,\n                key: await invokeAsync(\n                    generateHKDF,\n                    PerformanceEvents.GenerateHKDF,\n                    this.logger,\n                    this.performanceClient,\n                    correlationId\n                )(baseKey),\n            };\n        } else {\n            // Encryption key doesn't exist or is invalid, generate a new one\n            const id = createNewGuid();\n            const baseKey = await invokeAsync(\n                generateBaseKey,\n                PerformanceEvents.GenerateBaseKey,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )();\n            const keyStr = invoke(\n                urlEncodeArr,\n                PerformanceEvents.UrlEncodeArr,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )(new Uint8Array(baseKey));\n            this.encryptionCookie = {\n                id: id,\n                key: await invokeAsync(\n                    generateHKDF,\n                    PerformanceEvents.GenerateHKDF,\n                    this.logger,\n                    this.performanceClient,\n                    correlationId\n                )(baseKey),\n            };\n\n            const cookieData = {\n                id: id,\n                key: keyStr,\n            };\n\n            cookies.setItem(\n                ENCRYPTION_KEY,\n                JSON.stringify(cookieData),\n                0, // Expiration - 0 means cookie will be cleared at the end of the browser session\n                true, // Secure flag\n                SameSiteOptions.None // SameSite must be None to support iframed apps\n            );\n        }\n\n        await invokeAsync(\n            this.importExistingCache.bind(this),\n            PerformanceEvents.ImportExistingCache,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )(correlationId);\n\n        // Register listener for cache updates in other tabs\n        this.broadcast.addEventListener(\"message\", this.updateCache.bind(this));\n\n        this.initialized = true;\n    }\n\n    getItem(key: string): string | null {\n        return window.localStorage.getItem(key);\n    }\n\n    getUserData(key: string): string | null {\n        if (!this.initialized) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.uninitializedPublicClientApplication\n            );\n        }\n        return this.memoryStorage.getItem(key);\n    }\n\n    async decryptData(\n        key: string,\n        data: EncryptedData,\n        correlationId: string\n    ): Promise<object | null> {\n        if (!this.initialized || !this.encryptionCookie) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.uninitializedPublicClientApplication\n            );\n        }\n\n        if (data.id !== this.encryptionCookie.id) {\n            // Data was encrypted with a different key. It must be removed because it is from a previous session.\n            this.performanceClient.incrementFields(\n                { encryptedCacheExpiredCount: 1 },\n                correlationId\n            );\n            return null;\n        }\n\n        const decryptedData = await invokeAsync(\n            decrypt,\n            PerformanceEvents.Decrypt,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )(\n            this.encryptionCookie.key,\n            data.nonce,\n            this.getContext(key),\n            data.data\n        );\n\n        if (!decryptedData) {\n            return null;\n        }\n\n        try {\n            return {\n                ...JSON.parse(decryptedData),\n                lastUpdatedAt: data.lastUpdatedAt,\n            };\n        } catch (e) {\n            this.performanceClient.incrementFields(\n                { encryptedCacheCorruptionCount: 1 },\n                correlationId\n            );\n            return null;\n        }\n    }\n\n    setItem(key: string, value: string): void {\n        window.localStorage.setItem(key, value);\n    }\n\n    async setUserData(\n        key: string,\n        value: string,\n        correlationId: string,\n        timestamp: string,\n        kmsi: boolean\n    ): Promise<void> {\n        if (!this.initialized || !this.encryptionCookie) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.uninitializedPublicClientApplication\n            );\n        }\n\n        if (kmsi) {\n            this.setItem(key, value);\n        } else {\n            const { data, nonce } = await invokeAsync(\n                encrypt,\n                PerformanceEvents.Encrypt,\n                this.logger,\n                this.performanceClient,\n                correlationId\n            )(this.encryptionCookie.key, value, this.getContext(key));\n            const encryptedData: EncryptedData = {\n                id: this.encryptionCookie.id,\n                nonce: nonce,\n                data: data,\n                lastUpdatedAt: timestamp,\n            };\n            this.setItem(key, JSON.stringify(encryptedData));\n        }\n\n        this.memoryStorage.setItem(key, value);\n\n        // Notify other frames to update their in-memory cache\n        this.broadcast.postMessage({\n            key: key,\n            value: value,\n            context: this.getContext(key),\n        });\n    }\n\n    removeItem(key: string): void {\n        if (this.memoryStorage.containsKey(key)) {\n            this.memoryStorage.removeItem(key);\n            this.broadcast.postMessage({\n                key: key,\n                value: null,\n                context: this.getContext(key),\n            });\n        }\n        window.localStorage.removeItem(key);\n    }\n\n    getKeys(): string[] {\n        return Object.keys(window.localStorage);\n    }\n\n    containsKey(key: string): boolean {\n        return window.localStorage.hasOwnProperty(key);\n    }\n\n    /**\n     * Removes all known MSAL keys from the cache\n     */\n    clear(): void {\n        // Removes all remaining MSAL cache items\n        this.memoryStorage.clear();\n\n        const accountKeys = getAccountKeys(this);\n        accountKeys.forEach((key) => this.removeItem(key));\n        const tokenKeys = getTokenKeys(this.clientId, this);\n        tokenKeys.idToken.forEach((key) => this.removeItem(key));\n        tokenKeys.accessToken.forEach((key) => this.removeItem(key));\n        tokenKeys.refreshToken.forEach((key) => this.removeItem(key));\n\n        // Clean up anything left\n        this.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.startsWith(CacheKeys.PREFIX) ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.removeItem(cacheKey);\n            }\n        });\n    }\n\n    /**\n     * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage\n     * @returns\n     */\n    private async importExistingCache(correlationId: string): Promise<void> {\n        if (!this.encryptionCookie) {\n            return;\n        }\n\n        let accountKeys = getAccountKeys(this);\n        accountKeys = await this.importArray(accountKeys, correlationId);\n        // Write valid account keys back to map\n        if (accountKeys.length) {\n            this.setItem(\n                CacheKeys.getAccountKeysCacheKey(),\n                JSON.stringify(accountKeys)\n            );\n        } else {\n            this.removeItem(CacheKeys.getAccountKeysCacheKey());\n        }\n\n        const tokenKeys: TokenKeys = getTokenKeys(this.clientId, this);\n        tokenKeys.idToken = await this.importArray(\n            tokenKeys.idToken,\n            correlationId\n        );\n        tokenKeys.accessToken = await this.importArray(\n            tokenKeys.accessToken,\n            correlationId\n        );\n        tokenKeys.refreshToken = await this.importArray(\n            tokenKeys.refreshToken,\n            correlationId\n        );\n        // Write valid token keys back to map\n        if (\n            tokenKeys.idToken.length ||\n            tokenKeys.accessToken.length ||\n            tokenKeys.refreshToken.length\n        ) {\n            this.setItem(\n                CacheKeys.getTokenKeysCacheKey(this.clientId),\n                JSON.stringify(tokenKeys)\n            );\n        } else {\n            this.removeItem(CacheKeys.getTokenKeysCacheKey(this.clientId));\n        }\n    }\n\n    /**\n     * Helper to decrypt and save cache entries\n     * @param key\n     * @returns\n     */\n    private async getItemFromEncryptedCache(\n        key: string,\n        correlationId: string\n    ): Promise<string | null> {\n        if (!this.encryptionCookie) {\n            return null;\n        }\n\n        const rawCache = this.getItem(key);\n        if (!rawCache) {\n            return null;\n        }\n\n        let encObj: EncryptedData;\n        try {\n            encObj = JSON.parse(rawCache);\n        } catch (e) {\n            // Not a valid encrypted object, remove\n            return null;\n        }\n\n        if (!isEncrypted(encObj)) {\n            // Data is not encrypted\n            this.performanceClient.incrementFields(\n                { unencryptedCacheCount: 1 },\n                correlationId\n            );\n            return rawCache;\n        }\n\n        if (encObj.id !== this.encryptionCookie.id) {\n            // Data was encrypted with a different key. It must be removed because it is from a previous session.\n            this.performanceClient.incrementFields(\n                { encryptedCacheExpiredCount: 1 },\n                correlationId\n            );\n            return null;\n        }\n\n        this.performanceClient.incrementFields(\n            { encryptedCacheCount: 1 },\n            correlationId\n        );\n\n        return invokeAsync(\n            decrypt,\n            PerformanceEvents.Decrypt,\n            this.logger,\n            this.performanceClient,\n            correlationId\n        )(\n            this.encryptionCookie.key,\n            encObj.nonce,\n            this.getContext(key),\n            encObj.data\n        );\n    }\n\n    /**\n     * Helper to decrypt and save an array of cache keys\n     * @param arr\n     * @returns Array of keys successfully imported\n     */\n    private async importArray(\n        arr: Array<string>,\n        correlationId: string\n    ): Promise<Array<string>> {\n        const importedArr: Array<string> = [];\n        const promiseArr: Array<Promise<void>> = [];\n        arr.forEach((key) => {\n            const promise = this.getItemFromEncryptedCache(\n                key,\n                correlationId\n            ).then((value) => {\n                if (value) {\n                    this.memoryStorage.setItem(key, value);\n                    importedArr.push(key);\n                } else {\n                    // If value is empty, unencrypted or expired remove\n                    this.removeItem(key);\n                }\n            });\n            promiseArr.push(promise);\n        });\n\n        await Promise.all(promiseArr);\n        return importedArr;\n    }\n\n    /**\n     * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries\n     * @param key\n     * @returns\n     */\n    private getContext(key: string): string {\n        let context = \"\";\n        if (key.includes(this.clientId)) {\n            context = this.clientId; // Used to bind encryption key to this appId\n        }\n\n        return context;\n    }\n\n    private updateCache(event: MessageEvent): void {\n        this.logger.trace(\"Updating internal cache from broadcast event\");\n        const perfMeasurement = this.performanceClient.startMeasurement(\n            PerformanceEvents.LocalStorageUpdated\n        );\n        perfMeasurement.add({ isBackground: true });\n\n        const { key, value, context } = event.data;\n        if (!key) {\n            this.logger.error(\"Broadcast event missing key\");\n            perfMeasurement.end({ success: false, errorCode: \"noKey\" });\n            return;\n        }\n\n        if (context && context !== this.clientId) {\n            this.logger.trace(\n                `Ignoring broadcast event from clientId: ${context}`\n            );\n            perfMeasurement.end({\n                success: false,\n                errorCode: \"contextMismatch\",\n            });\n            return;\n        }\n\n        if (!value) {\n            this.memoryStorage.removeItem(key);\n            this.logger.verbose(\"Removed item from internal cache\");\n        } else {\n            this.memoryStorage.setItem(key, value);\n            this.logger.verbose(\"Updated item in internal cache\");\n        }\n        perfMeasurement.end({ success: true });\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;;AAGG;AAkCH,MAAMA,cAAc,GAAG,uBAAuB;AAC9C,MAAMC,sBAAsB,GAAG,sBAAsB;MAOxCC,YAAY;EASrBC,YACIC,QAAgB,EAChBC,MAAc,EACdC,iBAAqC;IAErC,IAAI,CAACC,MAAM,CAACC,YAAY,EAAE;MACtB,MAAMC,mCAAmC,CACrCC,mBAAsD,CACzD;IACJ;IACD,IAAI,CAACC,aAAa,GAAG,IAAIC,aAAa,EAAU;IAChD,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACT,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACQ,SAAS,GAAG,IAAIC,gBAAgB,CAACd,sBAAsB,CAAC;;EAGjE,MAAMe,UAAUA,CAACC,aAAqB;IAClC,MAAMC,OAAO,GAAG,IAAIC,aAAa,EAAE;IACnC,MAAMC,YAAY,GAAGF,OAAO,CAACG,OAAO,CAACrB,cAAc,CAAC;IACpD,IAAIsB,YAAY,GAAG;MAAEC,GAAG,EAAE,EAAE;MAAEC,EAAE,EAAE;IAAE,CAAE;IACtC,IAAIJ,YAAY,EAAE;MACd,IAAI;QACAE,YAAY,GAAGG,IAAI,CAACC,KAAK,CAACN,YAAY,CAAC;MAC1C,EAAC,OAAOO,CAAC,EAAE;IACf;IACD,IAAIL,YAAY,CAACC,GAAG,IAAID,YAAY,CAACE,EAAE,EAAE;;MAErC,MAAMI,OAAO,GAAGC,MAAM,CAClBC,cAAc,EACdC,iBAAiB,CAACC,YAAY,EAC9B,IAAI,CAAC3B,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CAACK,YAAY,CAACC,GAAG,CAAC;MACnB,IAAI,CAACU,gBAAgB,GAAG;QACpBT,EAAE,EAAEF,YAAY,CAACE,EAAE;QACnBD,GAAG,EAAE,MAAMW,WAAW,CAClBC,YAAY,EACZJ,iBAAiB,CAACK,YAAY,EAC9B,IAAI,CAAC/B,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CAACW,OAAO;OACZ;IACJ,OAAM;;MAEH,MAAMJ,EAAE,GAAGa,aAAa,EAAE;MAC1B,MAAMT,OAAO,GAAG,MAAMM,WAAW,CAC7BI,eAAe,EACfP,iBAAiB,CAACQ,eAAe,EACjC,IAAI,CAAClC,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,EAAE;MACH,MAAMuB,MAAM,GAAGX,MAAM,CACjBY,YAAY,EACZV,iBAAiB,CAACW,YAAY,EAC9B,IAAI,CAACrC,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CAAC,IAAI0B,UAAU,CAACf,OAAO,CAAC,CAAC;MAC1B,IAAI,CAACK,gBAAgB,GAAG;QACpBT,EAAE,EAAEA,EAAE;QACND,GAAG,EAAE,MAAMW,WAAW,CAClBC,YAAY,EACZJ,iBAAiB,CAACK,YAAY,EAC9B,IAAI,CAAC/B,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CAACW,OAAO;OACZ;MAED,MAAMgB,UAAU,GAAG;QACfpB,EAAE,EAAEA,EAAE;QACND,GAAG,EAAEiB;OACR;MAEDtB,OAAO,CAAC2B,OAAO,CACX7C,cAAc,EACdyB,IAAI,CAACqB,SAAS,CAACF,UAAU,CAAC,EAC1B,CAAC;MAAA;MACD,IAAI;MAAA;MACJG,eAAe,CAACC,IAAI;OACvB;IACJ;IAED,MAAMd,WAAW,CACb,IAAI,CAACe,mBAAmB,CAACC,IAAI,CAAC,IAAI,CAAC,EACnCnB,iBAAiB,CAACoB,mBAAmB,EACrC,IAAI,CAAC9C,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CAACA,aAAa,CAAC;;IAGhB,IAAI,CAACH,SAAS,CAACsC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACC,WAAW,CAACH,IAAI,CAAC,IAAI,CAAC,CAAC;IAEvE,IAAI,CAACrC,WAAW,GAAG,IAAI;;EAG3BQ,OAAOA,CAACE,GAAW;IACf,OAAOhB,MAAM,CAACC,YAAY,CAACa,OAAO,CAACE,GAAG,CAAC;;EAG3C+B,WAAWA,CAAC/B,GAAW;IACnB,IAAI,CAAC,IAAI,CAACV,WAAW,EAAE;MACnB,MAAM0C,sBAAsB,CACxBC,oCAA0D,CAC7D;IACJ;IACD,OAAO,IAAI,CAAC7C,aAAa,CAACU,OAAO,CAACE,GAAG,CAAC;;EAG1C,MAAMkC,WAAWA,CACblC,GAAW,EACXmC,IAAmB,EACnBzC,aAAqB;IAErB,IAAI,CAAC,IAAI,CAACJ,WAAW,IAAI,CAAC,IAAI,CAACoB,gBAAgB,EAAE;MAC7C,MAAMsB,sBAAsB,CACxBC,oCAA0D,CAC7D;IACJ;IAED,IAAIE,IAAI,CAAClC,EAAE,KAAK,IAAI,CAACS,gBAAgB,CAACT,EAAE,EAAE;;MAEtC,IAAI,CAAClB,iBAAiB,CAACqD,eAAe,CAClC;QAAEC,0BAA0B,EAAE;MAAC,CAAE,EACjC3C,aAAa,CAChB;MACD,OAAO,IAAI;IACd;IAED,MAAM4C,aAAa,GAAG,MAAM3B,WAAW,CACnC4B,OAAO,EACP/B,iBAAiB,CAACgC,OAAO,EACzB,IAAI,CAAC1D,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CACG,IAAI,CAACgB,gBAAgB,CAACV,GAAG,EACzBmC,IAAI,CAACM,KAAK,EACV,IAAI,CAACC,UAAU,CAAC1C,GAAG,CAAC,EACpBmC,IAAI,CAACA,IAAI,CACZ;IAED,IAAI,CAACG,aAAa,EAAE;MAChB,OAAO,IAAI;IACd;IAED,IAAI;MACA,OAAAK,aAAA,CAAAA,aAAA,KACOzC,IAAI,CAACC,KAAK,CAACmC,aAAa,CAAC;QAC5BM,aAAa,EAAET,IAAI,CAACS;MAAa;IAExC,EAAC,OAAOxC,CAAC,EAAE;MACR,IAAI,CAACrB,iBAAiB,CAACqD,eAAe,CAClC;QAAES,6BAA6B,EAAE;MAAC,CAAE,EACpCnD,aAAa,CAChB;MACD,OAAO,IAAI;IACd;;EAGL4B,OAAOA,CAACtB,GAAW,EAAE8C,KAAa;IAC9B9D,MAAM,CAACC,YAAY,CAACqC,OAAO,CAACtB,GAAG,EAAE8C,KAAK,CAAC;;EAG3C,MAAMC,WAAWA,CACb/C,GAAW,EACX8C,KAAa,EACbpD,aAAqB,EACrBsD,SAAiB,EACjBC,IAAa;IAEb,IAAI,CAAC,IAAI,CAAC3D,WAAW,IAAI,CAAC,IAAI,CAACoB,gBAAgB,EAAE;MAC7C,MAAMsB,sBAAsB,CACxBC,oCAA0D,CAC7D;IACJ;IAED,IAAIgB,IAAI,EAAE;MACN,IAAI,CAAC3B,OAAO,CAACtB,GAAG,EAAE8C,KAAK,CAAC;IAC3B,OAAM;MACH,MAAM;QAAEX,IAAI;QAAEM;MAAK,CAAE,GAAG,MAAM9B,WAAW,CACrCuC,OAAO,EACP1C,iBAAiB,CAAC2C,OAAO,EACzB,IAAI,CAACrE,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CAAC,IAAI,CAACgB,gBAAgB,CAACV,GAAG,EAAE8C,KAAK,EAAE,IAAI,CAACJ,UAAU,CAAC1C,GAAG,CAAC,CAAC;MACzD,MAAMoD,aAAa,GAAkB;QACjCnD,EAAE,EAAE,IAAI,CAACS,gBAAgB,CAACT,EAAE;QAC5BwC,KAAK,EAAEA,KAAK;QACZN,IAAI,EAAEA,IAAI;QACVS,aAAa,EAAEI;OAClB;MACD,IAAI,CAAC1B,OAAO,CAACtB,GAAG,EAAEE,IAAI,CAACqB,SAAS,CAAC6B,aAAa,CAAC,CAAC;IACnD;IAED,IAAI,CAAChE,aAAa,CAACkC,OAAO,CAACtB,GAAG,EAAE8C,KAAK,CAAC;;IAGtC,IAAI,CAACvD,SAAS,CAAC8D,WAAW,CAAC;MACvBrD,GAAG,EAAEA,GAAG;MACR8C,KAAK,EAAEA,KAAK;MACZQ,OAAO,EAAE,IAAI,CAACZ,UAAU,CAAC1C,GAAG;IAC/B,EAAC;;EAGNuD,UAAUA,CAACvD,GAAW;IAClB,IAAI,IAAI,CAACZ,aAAa,CAACoE,WAAW,CAACxD,GAAG,CAAC,EAAE;MACrC,IAAI,CAACZ,aAAa,CAACmE,UAAU,CAACvD,GAAG,CAAC;MAClC,IAAI,CAACT,SAAS,CAAC8D,WAAW,CAAC;QACvBrD,GAAG,EAAEA,GAAG;QACR8C,KAAK,EAAE,IAAI;QACXQ,OAAO,EAAE,IAAI,CAACZ,UAAU,CAAC1C,GAAG;MAC/B,EAAC;IACL;IACDhB,MAAM,CAACC,YAAY,CAACsE,UAAU,CAACvD,GAAG,CAAC;;EAGvCyD,OAAOA,CAAA;IACH,OAAOC,MAAM,CAACC,IAAI,CAAC3E,MAAM,CAACC,YAAY,CAAC;;EAG3CuE,WAAWA,CAACxD,GAAW;IACnB,OAAOhB,MAAM,CAACC,YAAY,CAAC2E,cAAc,CAAC5D,GAAG,CAAC;;EAGlD;;AAEG;EACH6D,KAAKA,CAAA;;IAED,IAAI,CAACzE,aAAa,CAACyE,KAAK,EAAE;IAE1B,MAAMC,WAAW,GAAGC,cAAc,CAAC,IAAI,CAAC;IACxCD,WAAW,CAACE,OAAO,CAAEhE,GAAG,IAAK,IAAI,CAACuD,UAAU,CAACvD,GAAG,CAAC,CAAC;IAClD,MAAMiE,SAAS,GAAGC,YAAY,CAAC,IAAI,CAACrF,QAAQ,EAAE,IAAI,CAAC;IACnDoF,SAAS,CAACE,OAAO,CAACH,OAAO,CAAEhE,GAAG,IAAK,IAAI,CAACuD,UAAU,CAACvD,GAAG,CAAC,CAAC;IACxDiE,SAAS,CAACG,WAAW,CAACJ,OAAO,CAAEhE,GAAG,IAAK,IAAI,CAACuD,UAAU,CAACvD,GAAG,CAAC,CAAC;IAC5DiE,SAAS,CAACI,YAAY,CAACL,OAAO,CAAEhE,GAAG,IAAK,IAAI,CAACuD,UAAU,CAACvD,GAAG,CAAC,CAAC;;IAG7D,IAAI,CAACyD,OAAO,EAAE,CAACO,OAAO,CAAEM,QAAgB,IAAI;MACxC,IACIA,QAAQ,CAACC,UAAU,CAACC,MAAgB,CAAC,IACrCF,QAAQ,CAACG,OAAO,CAAC,IAAI,CAAC5F,QAAQ,CAAC,KAAK,EAAE,EACxC;QACE,IAAI,CAAC0E,UAAU,CAACe,QAAQ,CAAC;MAC5B;IACL,CAAC,CAAC;;EAGN;;;AAGG;EACK,MAAM5C,mBAAmBA,CAAChC,aAAqB;IACnD,IAAI,CAAC,IAAI,CAACgB,gBAAgB,EAAE;MACxB;IACH;IAED,IAAIoD,WAAW,GAAGC,cAAc,CAAC,IAAI,CAAC;IACtCD,WAAW,GAAG,MAAM,IAAI,CAACY,WAAW,CAACZ,WAAW,EAAEpE,aAAa,CAAC;;IAEhE,IAAIoE,WAAW,CAACa,MAAM,EAAE;MACpB,IAAI,CAACrD,OAAO,CACRsD,sBAAgC,EAAE,EAClC1E,IAAI,CAACqB,SAAS,CAACuC,WAAW,CAAC,CAC9B;IACJ,OAAM;MACH,IAAI,CAACP,UAAU,CAACqB,sBAAgC,EAAE,CAAC;IACtD;IAED,MAAMX,SAAS,GAAcC,YAAY,CAAC,IAAI,CAACrF,QAAQ,EAAE,IAAI,CAAC;IAC9DoF,SAAS,CAACE,OAAO,GAAG,MAAM,IAAI,CAACO,WAAW,CACtCT,SAAS,CAACE,OAAO,EACjBzE,aAAa,CAChB;IACDuE,SAAS,CAACG,WAAW,GAAG,MAAM,IAAI,CAACM,WAAW,CAC1CT,SAAS,CAACG,WAAW,EACrB1E,aAAa,CAChB;IACDuE,SAAS,CAACI,YAAY,GAAG,MAAM,IAAI,CAACK,WAAW,CAC3CT,SAAS,CAACI,YAAY,EACtB3E,aAAa,CAChB;;IAED,IACIuE,SAAS,CAACE,OAAO,CAACQ,MAAM,IACxBV,SAAS,CAACG,WAAW,CAACO,MAAM,IAC5BV,SAAS,CAACI,YAAY,CAACM,MAAM,EAC/B;MACE,IAAI,CAACrD,OAAO,CACRuD,oBAA8B,CAAC,IAAI,CAAChG,QAAQ,CAAC,EAC7CqB,IAAI,CAACqB,SAAS,CAAC0C,SAAS,CAAC,CAC5B;IACJ,OAAM;MACH,IAAI,CAACV,UAAU,CAACsB,oBAA8B,CAAC,IAAI,CAAChG,QAAQ,CAAC,CAAC;IACjE;;EAGL;;;;AAIG;EACK,MAAMiG,yBAAyBA,CACnC9E,GAAW,EACXN,aAAqB;IAErB,IAAI,CAAC,IAAI,CAACgB,gBAAgB,EAAE;MACxB,OAAO,IAAI;IACd;IAED,MAAMqE,QAAQ,GAAG,IAAI,CAACjF,OAAO,CAACE,GAAG,CAAC;IAClC,IAAI,CAAC+E,QAAQ,EAAE;MACX,OAAO,IAAI;IACd;IAED,IAAIC,MAAqB;IACzB,IAAI;MACAA,MAAM,GAAG9E,IAAI,CAACC,KAAK,CAAC4E,QAAQ,CAAC;IAChC,EAAC,OAAO3E,CAAC,EAAE;;MAER,OAAO,IAAI;IACd;IAED,IAAI,CAAC6E,WAAW,CAACD,MAAM,CAAC,EAAE;;MAEtB,IAAI,CAACjG,iBAAiB,CAACqD,eAAe,CAClC;QAAE8C,qBAAqB,EAAE;MAAC,CAAE,EAC5BxF,aAAa,CAChB;MACD,OAAOqF,QAAQ;IAClB;IAED,IAAIC,MAAM,CAAC/E,EAAE,KAAK,IAAI,CAACS,gBAAgB,CAACT,EAAE,EAAE;;MAExC,IAAI,CAAClB,iBAAiB,CAACqD,eAAe,CAClC;QAAEC,0BAA0B,EAAE;MAAC,CAAE,EACjC3C,aAAa,CAChB;MACD,OAAO,IAAI;IACd;IAED,IAAI,CAACX,iBAAiB,CAACqD,eAAe,CAClC;MAAE+C,mBAAmB,EAAE;IAAC,CAAE,EAC1BzF,aAAa,CAChB;IAED,OAAOiB,WAAW,CACd4B,OAAO,EACP/B,iBAAiB,CAACgC,OAAO,EACzB,IAAI,CAAC1D,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBW,aAAa,CAChB,CACG,IAAI,CAACgB,gBAAgB,CAACV,GAAG,EACzBgF,MAAM,CAACvC,KAAK,EACZ,IAAI,CAACC,UAAU,CAAC1C,GAAG,CAAC,EACpBgF,MAAM,CAAC7C,IAAI,CACd;;EAGL;;;;AAIG;EACK,MAAMuC,WAAWA,CACrBU,GAAkB,EAClB1F,aAAqB;IAErB,MAAM2F,WAAW,GAAkB,EAAE;IACrC,MAAMC,UAAU,GAAyB,EAAE;IAC3CF,GAAG,CAACpB,OAAO,CAAEhE,GAAG,IAAI;MAChB,MAAMuF,OAAO,GAAG,IAAI,CAACT,yBAAyB,CAC1C9E,GAAG,EACHN,aAAa,CAChB,CAAC8F,IAAI,CAAE1C,KAAK,IAAI;QACb,IAAIA,KAAK,EAAE;UACP,IAAI,CAAC1D,aAAa,CAACkC,OAAO,CAACtB,GAAG,EAAE8C,KAAK,CAAC;UACtCuC,WAAW,CAACI,IAAI,CAACzF,GAAG,CAAC;QACxB,OAAM;;UAEH,IAAI,CAACuD,UAAU,CAACvD,GAAG,CAAC;QACvB;MACL,CAAC,CAAC;MACFsF,UAAU,CAACG,IAAI,CAACF,OAAO,CAAC;IAC5B,CAAC,CAAC;IAEF,MAAMG,OAAO,CAACC,GAAG,CAACL,UAAU,CAAC;IAC7B,OAAOD,WAAW;;EAGtB;;;;AAIG;EACK3C,UAAUA,CAAC1C,GAAW;IAC1B,IAAIsD,OAAO,GAAG,EAAE;IAChB,IAAItD,GAAG,CAAC4F,QAAQ,CAAC,IAAI,CAAC/G,QAAQ,CAAC,EAAE;MAC7ByE,OAAO,GAAG,IAAI,CAACzE,QAAQ,CAAC;IAC3B;IAED,OAAOyE,OAAO;;EAGVxB,WAAWA,CAAC+D,KAAmB;IACnC,IAAI,CAAC/G,MAAM,CAACgH,KAAK,CAAC,8CAA8C,CAAC;IACjE,MAAMC,eAAe,GAAG,IAAI,CAAChH,iBAAiB,CAACiH,gBAAgB,CAC3DxF,iBAAiB,CAACyF,mBAAmB,CACxC;IACDF,eAAe,CAACG,GAAG,CAAC;MAAEC,YAAY,EAAE;IAAI,CAAE,CAAC;IAE3C,MAAM;MAAEnG,GAAG;MAAE8C,KAAK;MAAEQ;IAAO,CAAE,GAAGuC,KAAK,CAAC1D,IAAI;IAC1C,IAAI,CAACnC,GAAG,EAAE;MACN,IAAI,CAAClB,MAAM,CAACsH,KAAK,CAAC,6BAA6B,CAAC;MAChDL,eAAe,CAACM,GAAG,CAAC;QAAEC,OAAO,EAAE,KAAK;QAAEC,SAAS,EAAE;MAAO,CAAE,CAAC;MAC3D;IACH;IAED,IAAIjD,OAAO,IAAIA,OAAO,KAAK,IAAI,CAACzE,QAAQ,EAAE;MACtC,IAAI,CAACC,MAAM,CAACgH,KAAK,4CAAAU,MAAA,CAC8BlD,OAAO,CAAE,CACvD;MACDyC,eAAe,CAACM,GAAG,CAAC;QAChBC,OAAO,EAAE,KAAK;QACdC,SAAS,EAAE;MACd,EAAC;MACF;IACH;IAED,IAAI,CAACzD,KAAK,EAAE;MACR,IAAI,CAAC1D,aAAa,CAACmE,UAAU,CAACvD,GAAG,CAAC;MAClC,IAAI,CAAClB,MAAM,CAAC2H,OAAO,CAAC,kCAAkC,CAAC;IAC1D,OAAM;MACH,IAAI,CAACrH,aAAa,CAACkC,OAAO,CAACtB,GAAG,EAAE8C,KAAK,CAAC;MACtC,IAAI,CAAChE,MAAM,CAAC2H,OAAO,CAAC,gCAAgC,CAAC;IACxD;IACDV,eAAe,CAACM,GAAG,CAAC;MAAEC,OAAO,EAAE;IAAI,CAAE,CAAC;;AAE7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}