{"ast":null,"code":"/*! @azure/msal-common v15.13.2 2025-11-19 */\n'use strict';\n\nimport { CacheAccountType } from '../../utils/Constants.mjs';\nimport { buildClientInfo } from '../../account/ClientInfo.mjs';\nimport { buildTenantProfile } from '../../account/AccountInfo.mjs';\nimport { createClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { AuthorityType } from '../../authority/AuthorityType.mjs';\nimport { getTenantIdFromIdTokenClaims } from '../../account/TokenClaims.mjs';\nimport { ProtocolMode } from '../../authority/ProtocolMode.mjs';\nimport { invalidCacheEnvironment } from '../../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      nativeAccountId: Account identifier on the native device\r\n *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser\r\n * }\r\n * @internal\r\n */\nclass AccountEntity {\n  /**\r\n   * Returns the AccountInfo interface for this account.\r\n   */\n  static getAccountInfo(accountEntity) {\n    return {\n      homeAccountId: accountEntity.homeAccountId,\n      environment: accountEntity.environment,\n      tenantId: accountEntity.realm,\n      username: accountEntity.username,\n      localAccountId: accountEntity.localAccountId,\n      loginHint: accountEntity.loginHint,\n      name: accountEntity.name,\n      nativeAccountId: accountEntity.nativeAccountId,\n      authorityType: accountEntity.authorityType,\n      // Deserialize tenant profiles array into a Map\n      tenantProfiles: new Map((accountEntity.tenantProfiles || []).map(tenantProfile => {\n        return [tenantProfile.tenantId, tenantProfile];\n      })),\n      dataBoundary: accountEntity.dataBoundary\n    };\n  }\n  /**\r\n   * Returns true if the account entity is in single tenant format (outdated), false otherwise\r\n   */\n  isSingleTenant() {\n    return !this.tenantProfiles;\n  }\n  /**\r\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n   * @param accountDetails\r\n   */\n  static createAccount(accountDetails, authority, base64Decode) {\n    const account = new AccountEntity();\n    if (authority.authorityType === AuthorityType.Adfs) {\n      account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\n    } else if (authority.protocolMode === ProtocolMode.OIDC) {\n      account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    } else {\n      account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    }\n    let clientInfo;\n    if (accountDetails.clientInfo && base64Decode) {\n      clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);\n      if (clientInfo.xms_tdbr) {\n        account.dataBoundary = clientInfo.xms_tdbr === \"EU\" ? \"EU\" : \"None\";\n      }\n    }\n    account.clientInfo = accountDetails.clientInfo;\n    account.homeAccountId = accountDetails.homeAccountId;\n    account.nativeAccountId = accountDetails.nativeAccountId;\n    const env = accountDetails.environment || authority && authority.getPreferredCache();\n    if (!env) {\n      throw createClientAuthError(invalidCacheEnvironment);\n    }\n    account.environment = env;\n    // non AAD scenarios can have empty realm\n    account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || \"\";\n    // How do you account for MSA CID here?\n    account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims?.oid || accountDetails.idTokenClaims?.sub || \"\";\n    /*\r\n     * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n     * In most cases it will contain a single email. This field should not be relied upon if a custom\r\n     * policy is configured to return more than 1 email.\r\n     */\n    const preferredUsername = accountDetails.idTokenClaims?.preferred_username || accountDetails.idTokenClaims?.upn;\n    const email = accountDetails.idTokenClaims?.emails ? accountDetails.idTokenClaims.emails[0] : null;\n    account.username = preferredUsername || email || \"\";\n    account.loginHint = accountDetails.idTokenClaims?.login_hint;\n    account.name = accountDetails.idTokenClaims?.name || \"\";\n    account.cloudGraphHostName = accountDetails.cloudGraphHostName;\n    account.msGraphHost = accountDetails.msGraphHost;\n    if (accountDetails.tenantProfiles) {\n      account.tenantProfiles = accountDetails.tenantProfiles;\n    } else {\n      const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);\n      account.tenantProfiles = [tenantProfile];\n    }\n    return account;\n  }\n  /**\r\n   * Creates an AccountEntity object from AccountInfo\r\n   * @param accountInfo\r\n   * @param cloudGraphHostName\r\n   * @param msGraphHost\r\n   * @returns\r\n   */\n  static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {\n    const account = new AccountEntity();\n    account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = accountInfo.homeAccountId;\n    account.localAccountId = accountInfo.localAccountId;\n    account.nativeAccountId = accountInfo.nativeAccountId;\n    account.realm = accountInfo.tenantId;\n    account.environment = accountInfo.environment;\n    account.username = accountInfo.username;\n    account.name = accountInfo.name;\n    account.loginHint = accountInfo.loginHint;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    // Serialize tenant profiles map into an array\n    account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);\n    account.dataBoundary = accountInfo.dataBoundary;\n    return account;\n  }\n  /**\r\n   * Generate HomeAccountId from server response\r\n   * @param serverClientInfo\r\n   * @param authType\r\n   */\n  static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {\n    // since ADFS/DSTS do not have tid and does not set client_info\n    if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {\n      // for cases where there is clientInfo\n      if (serverClientInfo) {\n        try {\n          const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);\n          if (clientInfo.uid && clientInfo.utid) {\n            return `${clientInfo.uid}.${clientInfo.utid}`;\n          }\n        } catch (e) {}\n      }\n      logger.warning(\"No client info in response\");\n    }\n    // default to \"sub\" claim\n    return idTokenClaims?.sub || \"\";\n  }\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n  static isAccountEntity(entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  }\n  /**\r\n   * Helper function to determine whether 2 accountInfo objects represent the same account\r\n   * @param accountA\r\n   * @param accountB\r\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n   */\n  static accountInfoIsEqual(accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n    let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n    if (compareClaims) {\n      const accountAClaims = accountA.idTokenClaims || {};\n      const accountBClaims = accountB.idTokenClaims || {};\n      // issued at timestamp and nonce are expected to change each time a new id token is acquired\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.loginHint === accountB.loginHint && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;\n  }\n}\nexport { AccountEntity };","map":{"version":3,"names":["AccountEntity","getAccountInfo","accountEntity","homeAccountId","environment","tenantId","realm","username","localAccountId","loginHint","name","nativeAccountId","authorityType","tenantProfiles","Map","map","tenantProfile","dataBoundary","isSingleTenant","createAccount","accountDetails","authority","base64Decode","account","AuthorityType","Adfs","CacheAccountType","ADFS_ACCOUNT_TYPE","protocolMode","ProtocolMode","OIDC","GENERIC_ACCOUNT_TYPE","MSSTS_ACCOUNT_TYPE","clientInfo","buildClientInfo","xms_tdbr","env","getPreferredCache","createClientAuthError","invalidCacheEnvironment","utid","getTenantIdFromIdTokenClaims","idTokenClaims","uid","oid","sub","preferredUsername","preferred_username","upn","email","emails","login_hint","cloudGraphHostName","msGraphHost","buildTenantProfile","createFromAccountInfo","accountInfo","Array","from","values","generateHomeAccountId","serverClientInfo","authType","logger","cryptoObj","Dsts","e","warning","isAccountEntity","entity","hasOwnProperty","accountInfoIsEqual","accountA","accountB","compareClaims","claimsMatch","accountAClaims","accountBClaims","iat","nonce"],"sources":["/Users/tolu/pangram-cos-350/frontend/node_modules/@azure/msal-common/src/cache/entities/AccountEntity.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CacheAccountType } from \"../../utils/Constants.js\";\nimport type { Authority } from \"../../authority/Authority.js\";\nimport { ICrypto } from \"../../crypto/ICrypto.js\";\nimport { ClientInfo, buildClientInfo } from \"../../account/ClientInfo.js\";\nimport {\n    AccountInfo,\n    TenantProfile,\n    buildTenantProfile,\n    DataBoundary,\n} from \"../../account/AccountInfo.js\";\nimport {\n    createClientAuthError,\n    ClientAuthErrorCodes,\n} from \"../../error/ClientAuthError.js\";\nimport { AuthorityType } from \"../../authority/AuthorityType.js\";\nimport { Logger } from \"../../logger/Logger.js\";\nimport {\n    TokenClaims,\n    getTenantIdFromIdTokenClaims,\n} from \"../../account/TokenClaims.js\";\nimport { ProtocolMode } from \"../../authority/ProtocolMode.js\";\n\n/**\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\n *\n * Key : Value Schema\n *\n * Key: <home_account_id>-<environment>-<realm*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\n *      authorityType: Accounts authority type as a string\n *      name: Full name for the account, including given name and family name,\n *      lastModificationTime: last time this entity was modified in the cache\n *      lastModificationApp:\n *      nativeAccountId: Account identifier on the native device\n *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser\n * }\n * @internal\n */\nexport class AccountEntity {\n    homeAccountId: string;\n    environment: string;\n    realm: string;\n    localAccountId: string;\n    username: string;\n    authorityType: string;\n    loginHint?: string;\n    clientInfo?: string;\n    name?: string;\n    lastModificationTime?: string;\n    lastModificationApp?: string;\n    cloudGraphHostName?: string;\n    msGraphHost?: string;\n    nativeAccountId?: string;\n    tenantProfiles?: Array<TenantProfile>;\n    lastUpdatedAt: string;\n    dataBoundary?: DataBoundary;\n\n    /**\n     * Returns the AccountInfo interface for this account.\n     */\n    static getAccountInfo(accountEntity: AccountEntity): AccountInfo {\n        return {\n            homeAccountId: accountEntity.homeAccountId,\n            environment: accountEntity.environment,\n            tenantId: accountEntity.realm,\n            username: accountEntity.username,\n            localAccountId: accountEntity.localAccountId,\n            loginHint: accountEntity.loginHint,\n            name: accountEntity.name,\n            nativeAccountId: accountEntity.nativeAccountId,\n            authorityType: accountEntity.authorityType,\n            // Deserialize tenant profiles array into a Map\n            tenantProfiles: new Map(\n                (accountEntity.tenantProfiles || []).map((tenantProfile) => {\n                    return [tenantProfile.tenantId, tenantProfile];\n                })\n            ),\n            dataBoundary: accountEntity.dataBoundary,\n        };\n    }\n\n    /**\n     * Returns true if the account entity is in single tenant format (outdated), false otherwise\n     */\n    isSingleTenant(): boolean {\n        return !this.tenantProfiles;\n    }\n\n    /**\n     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\n     * @param accountDetails\n     */\n    static createAccount(\n        accountDetails: {\n            homeAccountId: string;\n            idTokenClaims?: TokenClaims;\n            clientInfo?: string;\n            cloudGraphHostName?: string;\n            msGraphHost?: string;\n            environment?: string;\n            nativeAccountId?: string;\n            tenantProfiles?: Array<TenantProfile>;\n        },\n        authority: Authority,\n        base64Decode?: (input: string) => string\n    ): AccountEntity {\n        const account: AccountEntity = new AccountEntity();\n\n        if (authority.authorityType === AuthorityType.Adfs) {\n            account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\n        } else if (authority.protocolMode === ProtocolMode.OIDC) {\n            account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\n        } else {\n            account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n        }\n\n        let clientInfo: ClientInfo | undefined;\n\n        if (accountDetails.clientInfo && base64Decode) {\n            clientInfo = buildClientInfo(\n                accountDetails.clientInfo,\n                base64Decode\n            );\n            if (clientInfo.xms_tdbr) {\n                account.dataBoundary =\n                    clientInfo.xms_tdbr === \"EU\" ? \"EU\" : \"None\";\n            }\n        }\n\n        account.clientInfo = accountDetails.clientInfo;\n        account.homeAccountId = accountDetails.homeAccountId;\n        account.nativeAccountId = accountDetails.nativeAccountId;\n\n        const env =\n            accountDetails.environment ||\n            (authority && authority.getPreferredCache());\n\n        if (!env) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.invalidCacheEnvironment\n            );\n        }\n\n        account.environment = env;\n        // non AAD scenarios can have empty realm\n        account.realm =\n            clientInfo?.utid ||\n            getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) ||\n            \"\";\n\n        // How do you account for MSA CID here?\n        account.localAccountId =\n            clientInfo?.uid ||\n            accountDetails.idTokenClaims?.oid ||\n            accountDetails.idTokenClaims?.sub ||\n            \"\";\n\n        /*\n         * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\n         * In most cases it will contain a single email. This field should not be relied upon if a custom\n         * policy is configured to return more than 1 email.\n         */\n        const preferredUsername =\n            accountDetails.idTokenClaims?.preferred_username ||\n            accountDetails.idTokenClaims?.upn;\n        const email = accountDetails.idTokenClaims?.emails\n            ? accountDetails.idTokenClaims.emails[0]\n            : null;\n\n        account.username = preferredUsername || email || \"\";\n        account.loginHint = accountDetails.idTokenClaims?.login_hint;\n        account.name = accountDetails.idTokenClaims?.name || \"\";\n\n        account.cloudGraphHostName = accountDetails.cloudGraphHostName;\n        account.msGraphHost = accountDetails.msGraphHost;\n\n        if (accountDetails.tenantProfiles) {\n            account.tenantProfiles = accountDetails.tenantProfiles;\n        } else {\n            const tenantProfile = buildTenantProfile(\n                accountDetails.homeAccountId,\n                account.localAccountId,\n                account.realm,\n                accountDetails.idTokenClaims\n            );\n            account.tenantProfiles = [tenantProfile];\n        }\n\n        return account;\n    }\n\n    /**\n     * Creates an AccountEntity object from AccountInfo\n     * @param accountInfo\n     * @param cloudGraphHostName\n     * @param msGraphHost\n     * @returns\n     */\n    static createFromAccountInfo(\n        accountInfo: AccountInfo,\n        cloudGraphHostName?: string,\n        msGraphHost?: string\n    ): AccountEntity {\n        const account: AccountEntity = new AccountEntity();\n\n        account.authorityType =\n            accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\n        account.homeAccountId = accountInfo.homeAccountId;\n        account.localAccountId = accountInfo.localAccountId;\n        account.nativeAccountId = accountInfo.nativeAccountId;\n\n        account.realm = accountInfo.tenantId;\n        account.environment = accountInfo.environment;\n\n        account.username = accountInfo.username;\n        account.name = accountInfo.name;\n        account.loginHint = accountInfo.loginHint;\n\n        account.cloudGraphHostName = cloudGraphHostName;\n        account.msGraphHost = msGraphHost;\n        // Serialize tenant profiles map into an array\n        account.tenantProfiles = Array.from(\n            accountInfo.tenantProfiles?.values() || []\n        );\n        account.dataBoundary = accountInfo.dataBoundary;\n\n        return account;\n    }\n\n    /**\n     * Generate HomeAccountId from server response\n     * @param serverClientInfo\n     * @param authType\n     */\n    static generateHomeAccountId(\n        serverClientInfo: string,\n        authType: AuthorityType,\n        logger: Logger,\n        cryptoObj: ICrypto,\n        idTokenClaims?: TokenClaims\n    ): string {\n        // since ADFS/DSTS do not have tid and does not set client_info\n        if (\n            !(\n                authType === AuthorityType.Adfs ||\n                authType === AuthorityType.Dsts\n            )\n        ) {\n            // for cases where there is clientInfo\n            if (serverClientInfo) {\n                try {\n                    const clientInfo = buildClientInfo(\n                        serverClientInfo,\n                        cryptoObj.base64Decode\n                    );\n                    if (clientInfo.uid && clientInfo.utid) {\n                        return `${clientInfo.uid}.${clientInfo.utid}`;\n                    }\n                } catch (e) {}\n            }\n            logger.warning(\"No client info in response\");\n        }\n\n        // default to \"sub\" claim\n        return idTokenClaims?.sub || \"\";\n    }\n\n    /**\n     * Validates an entity: checks for all expected params\n     * @param entity\n     */\n    static isAccountEntity(entity: object): entity is AccountEntity {\n        if (!entity) {\n            return false;\n        }\n\n        return (\n            entity.hasOwnProperty(\"homeAccountId\") &&\n            entity.hasOwnProperty(\"environment\") &&\n            entity.hasOwnProperty(\"realm\") &&\n            entity.hasOwnProperty(\"localAccountId\") &&\n            entity.hasOwnProperty(\"username\") &&\n            entity.hasOwnProperty(\"authorityType\")\n        );\n    }\n\n    /**\n     * Helper function to determine whether 2 accountInfo objects represent the same account\n     * @param accountA\n     * @param accountB\n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\n     */\n    static accountInfoIsEqual(\n        accountA: AccountInfo | null,\n        accountB: AccountInfo | null,\n        compareClaims?: boolean\n    ): boolean {\n        if (!accountA || !accountB) {\n            return false;\n        }\n\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n        if (compareClaims) {\n            const accountAClaims = (accountA.idTokenClaims ||\n                {}) as TokenClaims;\n            const accountBClaims = (accountB.idTokenClaims ||\n                {}) as TokenClaims;\n\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\n            claimsMatch =\n                accountAClaims.iat === accountBClaims.iat &&\n                accountAClaims.nonce === accountBClaims.nonce;\n        }\n\n        return (\n            accountA.homeAccountId === accountB.homeAccountId &&\n            accountA.localAccountId === accountB.localAccountId &&\n            accountA.username === accountB.username &&\n            accountA.tenantId === accountB.tenantId &&\n            accountA.loginHint === accountB.loginHint &&\n            accountA.environment === accountB.environment &&\n            accountA.nativeAccountId === accountB.nativeAccountId &&\n            claimsMatch\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}